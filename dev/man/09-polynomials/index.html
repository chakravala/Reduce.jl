<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>9 Polynomials and Rationals · Reduce.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reduce.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Reduce.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../library/">Library</a></li><li><span class="tocitem">User&#39;s Manual</span><ul><li><a class="tocitem" href="../acknowledgement/">Acknowledgement</a></li><li><a class="tocitem" href="../01-introduction/">1 Introductory Information</a></li><li><a class="tocitem" href="../02-structure/">2 Structure of Programs</a></li><li><a class="tocitem" href="../03-expressions/">3 Expressions</a></li><li><a class="tocitem" href="../04-lists/">4 Lists</a></li><li><a class="tocitem" href="../05-statements/">5 Statements</a></li><li><a class="tocitem" href="../06-commands-declarations/">6 Commands and Declarations</a></li><li><a class="tocitem" href="../07-prefix-ops/">7 Built-in Prefix Operators</a></li><li><a class="tocitem" href="../08-display/">8 Display and Structuring of Expressions</a></li><li class="is-active"><a class="tocitem" href>9 Polynomials and Rationals</a><ul class="internal"><li><a class="tocitem" href="#.1-Controlling-the-Expansion-of-Expressions"><span>9.1 Controlling the Expansion of Expressions</span></a></li><li><a class="tocitem" href="#.2-Factorization-of-Polynomials"><span>9.2 Factorization of Polynomials</span></a></li><li><a class="tocitem" href="#.3-Cancellation-of-Common-Factors"><span>9.3 Cancellation of Common Factors</span></a></li><li><a class="tocitem" href="#.4-Working-with-Least-Common-Multiples"><span>9.4 Working with Least Common Multiples</span></a></li><li><a class="tocitem" href="#.5-Controlling-Use-of-Common-Denominators"><span>9.5 Controlling Use of Common Denominators</span></a></li><li><a class="tocitem" href="#.6-REMAINDER-Operator"><span>9.6 REMAINDER Operator</span></a></li><li><a class="tocitem" href="#.7-RESULTANT-Operator"><span>9.7 RESULTANT Operator</span></a></li><li><a class="tocitem" href="#.8-DECOMPOSE-Operator"><span>9.8 DECOMPOSE Operator</span></a></li><li><a class="tocitem" href="#.9-INTERPOL-operator"><span>9.9 INTERPOL operator</span></a></li><li><a class="tocitem" href="#.10-Obtaining-Parts-of-Polynomials-and-Rationals"><span>9.10 Obtaining Parts of Polynomials and Rationals</span></a></li><li><a class="tocitem" href="#.11-Polynomial-Coefficient-Arithmetic"><span>9.11 Polynomial Coefficient Arithmetic</span></a></li><li><a class="tocitem" href="#.12-ROOT_VAL-Operator"><span>9.12 ROOT_VAL Operator</span></a></li></ul></li><li><a class="tocitem" href="../10-properties/">10 Assigning and Testing Algebraic Properties</a></li><li><a class="tocitem" href="../11-substitution/">11 Substitution Commands</a></li><li><a class="tocitem" href="../12-file-io/">12 File Handling Commands</a></li><li><a class="tocitem" href="../13-interactive/">13 Commands for Interactive Use</a></li><li><a class="tocitem" href="../14-matrix/">14 Matrix Calculations</a></li><li><a class="tocitem" href="../15-procedures/">15 Procedures</a></li><li><a class="tocitem" href="../16-packages/">16 User Contributed Packages</a></li><li><a class="tocitem" href="../17-symbolic/">17 Symbolic Mode</a></li><li><a class="tocitem" href="../18-physics/">18 Calculations in High Energy Physics</a></li><li><a class="tocitem" href="../19-rlisp/">19 REDUCE and Rlisp Utilities</a></li><li><a class="tocitem" href="../20-maintaining/">20 Maintaining REDUCE</a></li><li><a class="tocitem" href="../A-reserved/">Appendix A: Reserved Identifiers</a></li><li><a class="tocitem" href="../B-bibliography/">Appendix B: Bibliography</a></li><li><a class="tocitem" href="../C-changelog/">Appendix C: Changes since Version 3.8</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User&#39;s Manual</a></li><li class="is-active"><a href>9 Polynomials and Rationals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>9 Polynomials and Rationals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/09-polynomials.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polynomials-and-Rationals"><a class="docs-heading-anchor" href="#Polynomials-and-Rationals">9 Polynomials and Rationals</a><a id="Polynomials-and-Rationals-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials-and-Rationals" title="Permalink"></a></h1><p>Many operations in computer algebra are concerned with polynomials and rational functions. In this section, we review some of the switches and operators available for this purpose. These are in addition to those that work on general expressions (such as <code>df</code> and <code>int</code>) described elsewhere. In the case of operators, the arguments are first simplified before the operations are applied. In addition, they operate only on arguments of prescribed types, and produce a type mismatch error if given arguments which cannot be interpreted in the required mode with the current switch settings. For example, if an argument is required to be a kernel and <code>a/2</code> is used (with no other rules for <code>a</code>), an error</p><pre><code class="nohighlight">        A/2 invalid as kernel</code></pre><p>will result.</p><p>With the exception of those that select various parts of a polynomial or rational function, these operations have potentially significant effects on the space and time associated with a given calculation. The user should therefore experiment with their use in a given calculation in order to determine the optimum set for a given problem.</p><p>One such operation provided by the system is an operator <code>length</code> which returns the number of top level terms in the numerator of its argument. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.length(:((a+b+c)^3/(c+d)))</code></pre><p>has the value 10. To get the number of terms in the denominator, one would first select the denominator by the operator <code>den</code> and then call <code>length</code>, as in</p><pre><code class="nohighlight">julia&gt; Algebra.length(Algebra.den(:((a+b+c)^3/(c+d))))</code></pre><p>Other operations currently supported, the relevant switches and operators, and the required argument and value modes of the latter, follow.</p><ul><li><a href="#Polynomials-and-Rationals">9 Polynomials and Rationals</a></li><ul><li><a href="#.1-Controlling-the-Expansion-of-Expressions">9.1 Controlling the Expansion of Expressions</a></li><li><a href="#.2-Factorization-of-Polynomials">9.2 Factorization of Polynomials</a></li><li><a href="#.3-Cancellation-of-Common-Factors">9.3 Cancellation of Common Factors</a></li><li><a href="#.4-Working-with-Least-Common-Multiples">9.4 Working with Least Common Multiples</a></li><li><a href="#.5-Controlling-Use-of-Common-Denominators">9.5 Controlling Use of Common Denominators</a></li><li><a href="#.6-REMAINDER-Operator">9.6 REMAINDER Operator</a></li><li><a href="#.7-RESULTANT-Operator">9.7 RESULTANT Operator</a></li><li><a href="#.8-DECOMPOSE-Operator">9.8 DECOMPOSE Operator</a></li><li><a href="#.9-INTERPOL-operator">9.9 INTERPOL operator</a></li><li><a href="#.10-Obtaining-Parts-of-Polynomials-and-Rationals">9.10 Obtaining Parts of Polynomials and Rationals</a></li><li><a href="#.11-Polynomial-Coefficient-Arithmetic">9.11 Polynomial Coefficient Arithmetic</a></li><li><a href="#.12-ROOT_VAL-Operator">9.12 ROOT_VAL Operator</a></li></ul></ul><h2 id=".1-Controlling-the-Expansion-of-Expressions"><a class="docs-heading-anchor" href="#.1-Controlling-the-Expansion-of-Expressions">9.1 Controlling the Expansion of Expressions</a><a id=".1-Controlling-the-Expansion-of-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Controlling-the-Expansion-of-Expressions" title="Permalink"></a></h2><p>The switch <code>exp</code> controls the expansion of expressions. If it is off, no expansion of powers or products of expressions occurs. Users should note however that in this case results come out in a normal but not necessarily canonical form. This means that zero expressions simplify to zero, but that two equivalent expressions need not necessarily simplify to the same form.</p><p><em>Example:</em> With <code>exp</code> on, the two expressions</p><pre><code class="nohighlight">(a+b)*(a+2*b)</code></pre><p>and</p><pre><code class="nohighlight">a^2+3*a*b+2*b^2</code></pre><p>will both simplify to the latter form. With <code>exp</code> off, they would remain unchanged, unless the complete factoring (<code>allfac</code>) option were in force. <code>exp</code> is normally on.</p><p><strong>Note that in Reduce.jl <code>exp</code> is turned off by default on initialization</strong></p><p>Several operators that expect a polynomial as an argument behave differently when <code>exp</code> is off, since there is often only one term at the top level. For example, with <code>exp</code> off</p><pre><code class="nohighlight">julia&gt; Algebra.length(:((a+b+c)^3/(c+d)))</code></pre><p>returns the value 1.</p><h2 id=".2-Factorization-of-Polynomials"><a class="docs-heading-anchor" href="#.2-Factorization-of-Polynomials">9.2 Factorization of Polynomials</a><a id=".2-Factorization-of-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Factorization-of-Polynomials" title="Permalink"></a></h2><p>REDUCE is capable of factorizing univariate and multivariate polynomials that have integer coefficients, finding all factors that also have integer coefficients. The package for doing this was written by Dr. Arthur C. Norman and Ms. P. Mary Ann Moore at The University of Cambridge. It is described in P. M. A. Moore and A. C. Norman, “Implementing a Polynomial Factorization and GCD Package”, Proc. SYMSAC ’81, ACM (New York) (1981), 109-116.</p><p>The easiest way to use this facility is to turn on the switch <code>factor</code>, which causes all expressions to be output in a factored form. For example, with <code>factor</code> on, the expression <code>a^2-b^2</code> is returned as <code>(a+b)*(a-b)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.factorize" href="#LinearAlgebra.factorize"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">factorize(r...)</code></pre><p>It is also possible to factorize a given expression explicitly. The operator <code>factorize</code> that invokes this facility is used with the syntax</p><pre><code class="language-Julia">R&quot;factorize(EXPRN:polynomial[,INTEXP:prime integer])&quot;</code></pre><p>the optional argument of which will be described later. Thus to find and display all factors of the cyclotomic polynomial <span>$x^{105} - 1$</span>, one could write:</p><pre><code class="nohighlight">julia&gt; Algebra.factorize(:(x^105-1))</code></pre><p>The result is a list of factor,exponent pairs. In the above example, there is no overall numerical factor in the result, so the results will consist only of polynomials in x. The number of such polynomials can be found by using the operator <code>length</code>. If there is a numerical factor, as in factorizing <span>$12x^2 - 12$</span>, that factor will appear as the first member of the result. It will however not be factored further. Prime factors of such numbers can be found, using a probabilistic algorithm, by turning on the switch <code>ifactor</code>. For example,</p><pre><code class="nohighlight">julia&gt; Algebra.on(:ifactor); Algebra.factorize(:(12x^2-12))</code></pre><p>would result in the output</p><pre><code class="nohighlight">((2, 2), (3, 1), (:(x ^ 2 + 1), 1), (:(x + 1), 1), (:(x - 1), 1))</code></pre><p>If the first argument of <code>factorize</code> is an integer, it will be decomposed into its prime components, whether or not <code>ifactor</code> is on.</p><p>Note that the <code>ifactor</code> switch only affects the result of <code>factorize</code>. It has no effect if the <code>factor</code> switch is also on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L765-L787">source</a></section></article><p>The order in which the factors occur in the result (with the exception of a possible overall numerical coefficient which comes first) can be system dependent and should not be relied on. Similarly it should be noted that any pair of individual factors can be negated without altering their product, and that REDUCE may sometimes do that.</p><p>The factorizer works by first reducing multivariate problems to univariate ones and then solving the univariate ones modulo small primes. It normally selects both evaluation points and primes using a random number generator that should lead to different detailed behavior each time any particular problem is tackled. If, for some reason, it is known that a certain (probably univariate) factorization can be performed effectively with a known prime, <code>p</code> say, this value of <code>p</code> can be handed to <code>factorize</code> as a second argument. An error will occur if a non-prime is provided to <code>factorize</code> in this manner. It is also an error to specify a prime that divides the discriminant of the polynomial being factored, but users should note that this condition is not checked by the program, so this capability should be used with care.</p><p>Factorization can be performed over a number of polynomial coefficient domains in addition to integers. The particular description of the relevant domain should be consulted to see if factorization is supported. For example, the following statements will factorize <span>$x^4 + 1$</span> modulo 7:</p><pre><code class="language-Julia">Algebra.setmod(7)
Algebra.on(:modular)
Algebra.factorize(:(x^4+1))</code></pre><p>The factorization module is provided with a trace facility that may be useful as a way of monitoring progress on large problems, and of satisfying curiosity about the internal workings of the package. The most simple use of this is enabled by issuing the REDUCE command <code>on(:trfac)</code>. Following this, all calls to the factorizer will generate informative messages reporting on such things as the reduction of multivariate to univariate cases, the choice of a prime and the reconstruction of full factors from their images. Further levels of detail in the trace are intended mainly for system tuners and for the investigation of suspected bugs. For example, <code>trallfac</code> gives tracing information at all levels of detail. The switch that can be set by <code>on(:timings)</code> makes it possible for one who is familiar with the algorithms used to determine what part of the factorization code is consuming the most resources. <code>on(:overview)</code> reduces the amount of detail presented in other forms of trace. Other forms of trace output are enabled by directives of the form</p><pre><code class="nohighlight">        symbolic set!-trace!-factor(&lt;number&gt;,&lt;filename&gt;);</code></pre><p>where useful numbers are 1, 2, 3 and 100, 101, ... . This facility is intended to make it possible to discover in fairly great detail what just some small part of the code has been doing — the numbers refer mainly to depths of recursion when the factorizer calls itself, and to the split between its work forming and factorizing images and reconstructing full factors from these. If <code>nil</code> is used in place of a filename the trace output requested is directed to the standard output stream. After use of this trace facility the generated trace files should be closed by calling</p><pre><code class="nohighlight">        symbolic close!-trace!-files();</code></pre><p><em>NOTE:</em> Using the factorizer with <code>mcd</code> off will result in an error.</p><h2 id=".3-Cancellation-of-Common-Factors"><a class="docs-heading-anchor" href="#.3-Cancellation-of-Common-Factors">9.3 Cancellation of Common Factors</a><a id=".3-Cancellation-of-Common-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Cancellation-of-Common-Factors" title="Permalink"></a></h2><p>Facilities are available in REDUCE for cancelling common factors in the numerators and denominators of expressions, at the option of the user. The system will perform this greatest common divisor computation if the switch <code>gcd</code> is on. (<code>gcd</code> is normally off.)</p><p>A check is automatically made, however, for common variable and numerical products in the numerators and denominators of expressions, and the appropriate cancellations made.</p><p>When <code>gcd</code> is on, and <code>exp</code> is off, a check is made for square free factors in an expression. This includes separating out and independently checking the content of a given polynomial where appropriate. (For an explanation of these terms, see Anthony C. Hearn, “Non-Modular Computation of Polynomial GCDs Using Trial Division”, Proc. EUROSAM 79, published as Lecture Notes on Comp. Science, Springer-Verlag, Berlin, No 72 (1979) 227-239.)</p><p><em>Example:</em> With <code>exp</code> off and <code>gcd</code> on, the polynomial <code>a*c+a*d+b*c+b*d</code> would be returned as <code>(a+b)*(c+d)</code>.</p><p>Under normal circumstances, GCDs are computed using an algorithm described in the above paper. It is also possible in REDUCE to compute GCDs using an alternative algorithm, called the EZGCD Algorithm, which uses modular arithmetic. The switch <code>ezgcd</code>, if on in addition to <code>gcd</code>, makes this happen.</p><p>In non-trivial cases, the EZGCD algorithm is almost always better than the basic algorithm, often by orders of magnitude. We therefore <em>strongly</em> advise users to use the <code>ezgcd</code> switch where they have the resources available for supporting the package.</p><p>For a description of the EZGCD algorithm, see J. Moses and D.Y.Y. Yun, “The EZ GCD Algorithm”, Proc. ACM 1973, ACM, New York (1973) 159-166.</p><p><em>NOTE:</em> This package shares code with the factorizer, so a certain amount of trace information can be produced using the factorizer trace switches.</p><p>An implementation of the heuristic GCD algorithm, first introduced by B.W. Char, K.O. Geddes and G.H. Gonnet, as described in J.H. Davenport and J. Padget, “HEUGCD: How Elementary Upperbounds Generate Cheaper Data”, Proc. of EUROCAL ’85, Vol 2, 18-28, published as Lecture Notes on Comp. Science, No. 204, Springer-Verlag, Berlin, 1985, is also available on an experimental basis. To use this algorithm, the switch <code>heugcd</code> should be on in addition to <code>gcd</code>. Note that if both <code>ezgcd</code> and <code>heugcd</code> are on, the former takes precedence.</p><h3 id=".3.1-Determining-the-GCD-of-Two-Polynomials"><a class="docs-heading-anchor" href="#.3.1-Determining-the-GCD-of-Two-Polynomials">9.3.1 Determining the GCD of Two Polynomials</a><a id=".3.1-Determining-the-GCD-of-Two-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.3.1-Determining-the-GCD-of-Two-Polynomials" title="Permalink"></a></h3><p>This operator, used with the syntax</p><pre><code class="language-Julia">R&quot;gcd(EXPRN1:polynomial,EXPRN2:polynomial)&quot;</code></pre><p>returns the greatest common divisor of the two polynomials <code>EXPRN1</code> and <code>EXPRN2</code>. <em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.gcd(:(x^2+2*x+1),:(x^2+3*x+2))
:(x + 1)

julia&gt; Algebra.gcd(:(2*x^2-2*y^2),:(4*x+4*y))
:(2 * (x + y))

julia&gt; Algebra.gcd(:(x^2+y^2),:(x-y))
1</code></pre><h2 id=".4-Working-with-Least-Common-Multiples"><a class="docs-heading-anchor" href="#.4-Working-with-Least-Common-Multiples">9.4 Working with Least Common Multiples</a><a id=".4-Working-with-Least-Common-Multiples-1"></a><a class="docs-heading-anchor-permalink" href="#.4-Working-with-Least-Common-Multiples" title="Permalink"></a></h2><p>Greatest common divisor calculations can often become expensive if extensive work with large rational expressions is required. However, in many cases, the only significant cancellations arise from the fact that there are often common factors in the various denominators which are combined when two rationals are added. Since these denominators tend to be smaller and more regular in structure than the numerators, considerable savings in both time and space can occur if a full GCD check is made when the denominators are combined and only a partial check when numerators are constructed. In other words, the true least common multiple of the denominators is computed at each step. The switch <code>lcm</code> is available for this purpose, and is normally on.</p><p>In addition, the operator <code>lcm</code>, used with the syntax</p><pre><code class="language-Julia">R&quot;lcm(EXPRN1:polynomial,EXPRN2:polynomial)&quot;</code></pre><p>returns the least common multiple of the two polynomials <code>EXPRN1</code> and <code>EXPRN2</code>.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.lcm(:(x^2+2*x+1),:(x^2+3*x+2))
:((x + 2) * (x + 1) ^ 2)

julia&gt; Algebra.lcm(:(2*x^2-2*y^2),:(4*x+4*y))
:(4 * (x ^ 2 - y ^ 2))</code></pre><h2 id=".5-Controlling-Use-of-Common-Denominators"><a class="docs-heading-anchor" href="#.5-Controlling-Use-of-Common-Denominators">9.5 Controlling Use of Common Denominators</a><a id=".5-Controlling-Use-of-Common-Denominators-1"></a><a class="docs-heading-anchor-permalink" href="#.5-Controlling-Use-of-Common-Denominators" title="Permalink"></a></h2><p>When two rational functions are added, REDUCE normally produces an expression over a common denominator. However, if the user does not want denominators combined, he or she can turn off the switch <code>mcd</code> which controls this process. The latter switch is particularly useful if no greatest common divisor calculations are desired, or excessive differentiation of rational functions is required.</p><p><em>CAUTION:</em> With <code>mcd</code> off, results are not guaranteed to come out in either normal or canonical form. In other words, an expression equivalent to zero may in fact not be simplified to zero. This option is therefore most useful for avoiding expression swell during intermediate parts of a calculation.</p><p><code>mcd</code> is normally on.</p><h2 id=".6-REMAINDER-Operator"><a class="docs-heading-anchor" href="#.6-REMAINDER-Operator">9.6 REMAINDER Operator</a><a id=".6-REMAINDER-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#.6-REMAINDER-Operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.remainder" href="#Reduce.Algebra.remainder"><code>Reduce.Algebra.remainder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remainder(a,b)</code></pre><p>This operator is used with the syntax</p><pre><code class="language-Julia">R&quot;REMAINDER(EXPRN1:polynomial,EXPRN2:polynomial)&quot;</code></pre><p>It returns the remainder when <code>EXPRN1</code> is divided by <code>EXPRN2</code>. This is the true remainder based on the internal ordering of the variables, and not the pseudo-remainder. The pseudo-remainder and in general pseudo-division of polynomials can be calculated after loading the <code>polydiv</code> package. Please refer to the documentation of this package for details.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp); Algebra.remainder(:((x+y)*(x+2*y)),:(x+3*y))
:(2 * y ^ 2)

julia&gt; Algebra.remainder(:(2*x+y),2)
:y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L789-L806">source</a></section></article><p><em>CAUTION:</em> In the default case, remainders are calculated over the integers. If you need the remainder with respect to another domain, it must be declared explicitly.</p><p><em>Example:</em></p><pre><code class="nohighlight">        remainder(x^2-2,x+sqrt(2)); -&gt; x^2 - 2  
        load_package arnum;  
        defpoly sqrt2**2-2;  
        remainder(x^2-2,x+sqrt2); -&gt; 0</code></pre><h2 id=".7-RESULTANT-Operator"><a class="docs-heading-anchor" href="#.7-RESULTANT-Operator">9.7 RESULTANT Operator</a><a id=".7-RESULTANT-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#.7-RESULTANT-Operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.resultant" href="#Reduce.Algebra.resultant"><code>Reduce.Algebra.resultant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resultant(a,b,var)</code></pre><p>This is used with the syntax</p><pre><code class="language-Julia">R&quot;resultant(EXPRN1:polynomial,EXPRN2:polynomial,VAR:kernel)&quot;</code></pre><p>It computes the resultant of the two given polynomials with respect to the given variable, the coefficients of the polynomials can be taken from any domain. The result can be identified as the determinant of a Sylvester matrix, but can often also be thought of informally as the result obtained when the given variable is eliminated between the two input polynomials. If the two input polynomials have a non-trivial GCD their resultant vanishes.</p><p>The switch <code>bezout</code> controls the computation of the resultants. It is off by default. In this case a subresultant algorithm is used. If the switch Bezout is turned on, the resultant is computed via the Bezout Matrix. However, in the latter case, only polynomial coefficients are permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L808-L818">source</a></section></article><p>The sign conventions used by the resultant function follow those in R. Loos, “Computing in Algebraic Extensions” in “Computer Algebra — Symbolic and Algebraic Computation”, Second Ed., Edited by B. Buchberger, G.E. Collins and R. Loos, Springer-Verlag, 1983. Namely, with <code>a</code> and <code>b</code> not dependent on <code>x</code>:</p><pre><code class="nohighlight">                               deg(p)*deg(q)  
   resultant(p(x),q(x),x)= (-1)             *resultant(q,p,x)  
 
                            deg(p)  
   resultant(a,p(x),x)   = a  
 
   resultant(a,b,x)      = 1</code></pre><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.resultant(:(x/r*u+y),:(u*y),:u)
:(-(y ^ 2))</code></pre><p>calculation in an algebraic extension:</p><pre><code class="nohighlight">   load arnum;  
   defpoly sqrt2**2 - 2;  
 
   resultant(x + sqrt2,sqrt2 * x +1,x) -&gt; -1</code></pre><p>or in a modular domain:</p><pre><code class="nohighlight">julia&gt; Algebra.setmod(17); Algebra.on(:modular);
 
julia&gt; Algebra.resultant(:(2x+1),:(3x+4),:x)
5</code></pre><h2 id=".8-DECOMPOSE-Operator"><a class="docs-heading-anchor" href="#.8-DECOMPOSE-Operator">9.8 DECOMPOSE Operator</a><a id=".8-DECOMPOSE-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#.8-DECOMPOSE-Operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.decompose" href="#Reduce.Algebra.decompose"><code>Reduce.Algebra.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decompose(p)</code></pre><p>The <code>decompose</code> operator takes a multivariate polynomial as argument, and returns an expression and a list of equations from which the original polynomial can be found by composition. Its syntax is:</p><pre><code class="language-Julia">R&quot;decompose(EXPRN:polynomial)&quot;</code></pre><p>For example:</p><pre><code class="language-Julia">julia&gt; Algebra.decompose(:(x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-218900*x^3+65690*x^2-7700*x+234))
(:(u ^ 2 + 35u + 234), :(u = v ^ 2 + 10v), :(v = x ^ 2 - 22x))

julia&gt; Algebra.decompose(:(u^2+v^2+2u*v+1))
(:(w ^ 2 + 1), :(w = u + v))</code></pre><p>Users should note however that, unlike factorization, this decomposition is not unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L591-L607">source</a></section></article><h2 id=".9-INTERPOL-operator"><a class="docs-heading-anchor" href="#.9-INTERPOL-operator">9.9 INTERPOL operator</a><a id=".9-INTERPOL-operator-1"></a><a class="docs-heading-anchor-permalink" href="#.9-INTERPOL-operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.interpol" href="#Reduce.Algebra.interpol"><code>Reduce.Algebra.interpol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interpol(val,var,mp)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;interpol(⟨values⟩,⟨variable⟩,metapoints)&quot;</code></pre><p>where <code>⟨values⟩</code> and <code>⟨points⟩</code> are lists of equal length and <code>&lt;variable&gt;</code> is an algebraic expression (preferably a kernel).</p><p><code>interpol</code> generates an interpolation polynomial <span>$f$</span> in the given variable of degree <code>length(⟨values⟩)-1</code>. The unique polynomial <span>$f$</span> is defined by the property that for corresponding elements <span>$v$</span> of <code>⟨values⟩</code> and <span>$p$</span> of <code>⟨points⟩</code> the relation <span>$f(p) = v$</span> holds.</p><p>The Aitken-Neville interpolation algorithm is used which guarantees a stable result even with rounded numbers and an ill-conditioned problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L820-L832">source</a></section></article><h2 id=".10-Obtaining-Parts-of-Polynomials-and-Rationals"><a class="docs-heading-anchor" href="#.10-Obtaining-Parts-of-Polynomials-and-Rationals">9.10 Obtaining Parts of Polynomials and Rationals</a><a id=".10-Obtaining-Parts-of-Polynomials-and-Rationals-1"></a><a class="docs-heading-anchor-permalink" href="#.10-Obtaining-Parts-of-Polynomials-and-Rationals" title="Permalink"></a></h2><p>These operators select various parts of a polynomial or rational function structure. Except for the cost of rearrangement of the structure, these operations take very little time to perform.</p><p>For those operators in this section that take a kernel <code>VAR</code> as their second argument, an error results if the first expression is not a polynomial in <code>VAR</code>, although the coefficients themselves can be rational as long as they do not depend on <code>VAR</code>. However, if the switch <code>ratarg</code> is on, denominators are not checked for dependence on <code>VAR</code>, and are taken to be part of the coefficients.</p><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.deg" href="#Reduce.Algebra.deg"><code>Reduce.Algebra.deg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deg(p,var)</code></pre><p>This operator is used with the syntax</p><pre><code class="language-Julia">R&quot;deg(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p>It returns the leading degree of the polynomial <code>EXPRN</code> in the variable <code>VAR</code>. If <code>VAR</code> does not occur as a variable in <code>EXPRN</code>, 0 is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.deg(:((a+b)*(c+2*d)^2),:a)
1

julia&gt; Algebra.deg(:((a+b)*(c+2*d)^2),:d)
2

julia&gt; Algebra.deg(:((a+b)*(c+2*d)^2),:e)
0</code></pre><p>Note also that if <code>ratarg</code> is on,</p><pre><code class="nohighlight">        deg((a+b)^3/a,a)       -&gt;  3</code></pre><p>since in this case, the denominator <code>a</code> is considered part of the coefficients of the numerator in <code>a</code>. With <code>ratarg</code> off, however, an error would result in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L834-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.den" href="#Reduce.Algebra.den"><code>Reduce.Algebra.den</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">den(r)</code></pre><p>This is used with the syntax:</p><pre><code class="language-Julia">R&quot;den(EXPRN:rational)&quot;</code></pre><p>It returns the denominator of the rational expression <code>EXPRN</code>. If <code>EXPRN</code> is a polynomial, 1 is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.den(:(x/y^2))
:(y ^ 2)

julia&gt; Algebra.den(100//6)
3               [since 100/6 is first simplified to 50/3]  

julia&gt; Algebra.den(:(a/4+b/6))
12

julia&gt; Algebra.den(:(a+b))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L611-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.lcof" href="#Reduce.Algebra.lcof"><code>Reduce.Algebra.lcof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lcof(expr,var)</code></pre><p><code>lcof</code> is used with the syntax</p><pre><code class="language-Julia">R&quot;lcof(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p>It returns the leading coefficient of the polynomial <code>EXPRN</code> in the variable <code>VAR</code>. If <code>VAR</code> does not occur as a variable in <code>EXPRN</code>, <code>EXPRN</code> is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.lcof(:((a+b)*(c+2*d)^2),:a)
:(c ^ 2 + 4 * c * d + 4 * d ^ 2)

julia&gt; Algebra.lcof(:((a+b)*(c+2*d)^2),:d)
:(4 * (a + b))

julia&gt; Algebra.lcof(:((a+b)*(c+2*d)),:e)
:(a * c + 2 * a * d + b * c + 2 * b * d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L863-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.lpower" href="#Reduce.Algebra.lpower"><code>Reduce.Algebra.lpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lpower(exprn,var)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;lpower(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p><code>lpower</code> returns the leading power of <code>EXPRN</code> with respect to <code>VAR</code>. If <code>EXPRN</code> does not depend on <code>VAR</code>, 1 is returned. <em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.lpower(:((a+b)*(c+2*d)^2),:a)
:a

julia&gt; Algebra.lpower(:((a+b)*(c+2*d)^2),:d)
:(d ^ 2)

julia&gt; Algebra.lpower(:((a+b)*(c+2*d)),:e)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L887-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.lterm" href="#Reduce.Algebra.lterm"><code>Reduce.Algebra.lterm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lterm(exprn,var)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;lterm(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p><code>lterm</code> returns the leading term of <code>EXPRN</code> with respect to <code>VAR</code>. If <code>EXPRN</code> does not depend on <code>VAR</code>, <code>EXPRN</code> is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.lterm(:((a+b)*(c+2*d)^2),:a)
:(a * (c ^ 2 + 4 * c * d + 4 * d ^ 2))

julia&gt; Algebra.lterm(:((a+b)*(c+2*d)^2),:d)
:(4 * d ^ 2 * (a + b))

julia&gt; Algebra.lterm(:((a+b)*(c+2*d)),:e)
:(a * c + 2 * a * d + b * c + 2 * b * d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L910-L932">source</a></section></article><p><em>Compatibility Note:</em>  In some earlier versions of REDUCE, <code>lterm</code> returned 0 if the <code>EXPRN</code> did not depend on <code>VAR</code>. In the present version, <code>EXPRN</code> is always equal to <code>lterm(EXPRN,VAR) + reduct(EXPRN,VAR)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.mainvar" href="#Reduce.Algebra.mainvar"><code>Reduce.Algebra.mainvar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mainvar(exprn)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;mainvar(EXPRN:polynomial)&quot;</code></pre><p>Returns the main variable (based on the internal polynomial representation) of <code>EXPRN</code>. If <code>EXPRN</code> is a domain element, 0 is returned.</p><p><em>Examples:</em> Assuming <code>a</code> has higher kernel order than <code>b</code>, <code>c</code>, or <code>d</code>:</p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.mainvar(:((a+b)*(c+2*d)^2))
:a

julia&gt; Algebra.mainvar(2)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L638-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.num" href="#Reduce.Algebra.num"><code>Reduce.Algebra.num</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num(exprn)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;num(EXPRN:rational)&quot;</code></pre><p>Returns the numerator of the rational expression <code>EXPRN</code>. If <code>EXPRN</code> is a polynomial, that polynomial is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.num(:(x/y^2))
:x

julia&gt; Algebra.num(100//6)
50

julia&gt; Algebra.num(:(a/4+b/6))
:(3a + 2b)

julia&gt; Algebra.num(:(a+b))
:(a + b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L661-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.reduct" href="#Reduce.Algebra.reduct"><code>Reduce.Algebra.reduct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reduct(exprn,var)</code></pre><p>Syntax:</p><pre><code class="language-Julia">R&quot;reduct(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p>Returns the reductum of <code>EXPRN</code> with respect to <code>VAR</code> (i.e., the part of <code>EXPRN</code> left after the leading term is removed). If <code>EXPRN</code> does not depend on the variable <code>VAR</code>, 0 is returned.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.on(:exp)

julia&gt; Algebra.reduct(:((a+b)*(c+2*d)),:a)
:(b * (c + 2d))

julia&gt; Algebra.reduct(:((a+b)*(c+2*d)),:d)
:(c * (a + b))

julia&gt; Algebra.reduct(:((a+b)*(c+2*d)),:e)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L934-L956">source</a></section></article><p><em>Compatibility Note:</em>  In some earlier versions of REDUCE, <code>reduct</code> returned <code>EXPRN</code> if it did not depend on <code>VAR</code>. In the present version, <code>EXPRN</code> is always equal to <code>lterm(EXPRN,VAR) + reduct(EXPRN,VAR)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.totaldeg" href="#Reduce.Algebra.totaldeg"><code>Reduce.Algebra.totaldeg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">totaldeg(expr,var)</code></pre><p>Syntax:</p><pre><code class="language-Julia">julia&gt; Algebra.totaldeg(:(a*x^2+b*x+c), :x)
2

julia&gt; Algebra.totaldeg(:(a*x^2+b*x+c), (:a,:b,:c))
1

julia&gt; Algebra.totaldeg(:(a*x^2+b*x+c), (:x, :a))
3

julia&gt; Algebra.totaldeg(:(a*x^2+b*x+c), (:x,:b))
2

julia&gt; Algebra.totaldeg(:(a*x^2+b*x+c), (:p,:q,:r))
0</code></pre><p><code>totaldeg(u, kernlist)</code> finds the total degree of the polynomial <code>u</code> in the variables in <code>kernlist</code>. If <code>kernlist</code> is not a list it is treated as a simple single variable. The denominator of <code>u</code> is ignored, and &quot;degree&quot; here does not pay attention to fractional powers. Mentions of a kernel within the argument to any operator or function (eg <code>sin</code>, <code>cos</code>, <code>log</code>, <code>sqrt</code>) are ignored. Really <code>u</code> is expected to be just a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/args.jl#L958-L979">source</a></section></article><h2 id=".11-Polynomial-Coefficient-Arithmetic"><a class="docs-heading-anchor" href="#.11-Polynomial-Coefficient-Arithmetic">9.11 Polynomial Coefficient Arithmetic</a><a id=".11-Polynomial-Coefficient-Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#.11-Polynomial-Coefficient-Arithmetic" title="Permalink"></a></h2><p>REDUCE allows for a variety of numerical domains for the numerical coefficients of polynomials used in calculations. The default mode is integer arithmetic, although the possibility of using real coefficients has been discussed elsewhere. Rational coefficients have also been available by using integer coefficients in both the numerator and denominator of an expression, using the <code>on(:div)</code> option to print the coefficients as rationals. However, REDUCE includes several other coefficient options in its basic version which we shall describe in this section. All such coefficient modes are supported in a table-driven manner so that it is straightforward to extend the range of possibilities. A description of how to do this is given in R.J. Bradford, A.C. Hearn, J.A. Padget and E. Schrüfer, “Enlarging the REDUCE Domain of Computation,” Proc. of SYMSAC ’86, ACM, New York (1986), 100–106.</p><h3 id=".11.1-Rational-Coefficients-in-Polynomials"><a class="docs-heading-anchor" href="#.11.1-Rational-Coefficients-in-Polynomials">9.11.1 Rational Coefficients in Polynomials</a><a id=".11.1-Rational-Coefficients-in-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.11.1-Rational-Coefficients-in-Polynomials" title="Permalink"></a></h3><p>Instead of treating rational numbers as the numerator and denominator of a rational expression, it is also possible to use them as polynomial coefficients directly. This is accomplished by turning on the switch <code>rational</code>.</p><p><em>Example:</em> With <code>rational</code> off, the input expression <code>a/2</code> would be converted into a rational expression, whose numerator was <code>a</code> and denominator <code>2</code>. With <code>rational</code> on, the same input would become a rational expression with numerator <code>1/2*a</code> and denominator <code>1</code>. Thus the latter can be used in operations that require polynomial input whereas the former could not.</p><h3 id=".11.2-Real-Coefficients-in-Polynomials"><a class="docs-heading-anchor" href="#.11.2-Real-Coefficients-in-Polynomials">9.11.2 Real Coefficients in Polynomials</a><a id=".11.2-Real-Coefficients-in-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.11.2-Real-Coefficients-in-Polynomials" title="Permalink"></a></h3><p>The switch <code>rounded</code> permits the use of arbitrary sized real coefficients in polynomial expressions. The actual precision of these coefficients can be set by the operator <code>precision</code>. For example, <code>precision(50)</code> sets the precision to fifty decimal digits. The default precision is system dependent and can be found by <code>precision(0)</code>. In this mode, denominators are automatically made monic, and an appropriate adjustment is made to the numerator.</p><p><em>Example:</em> With <code>rounded</code> on, the input expression <code>a/2</code> would be converted into a rational expression whose numerator is <code>0.5*a</code> and denominator <code>1</code>.</p><p>Internally, REDUCE uses floating point numbers up to the precision supported by the underlying machine hardware, and so-called <em>bigfloats</em> for higher precision or whenever necessary to represent numbers whose value cannot be represented in floating point. The internal precision is two decimal digits greater than the external precision to guard against roundoff inaccuracies. Bigfloats represent the fraction and exponent parts of a floating-point number by means of (arbitrary precision) integers, which is a more precise representation in many cases than the machine floating point arithmetic, but not as efficient. If a case arises where use of the machine arithmetic leads to problems, a user can force REDUCE to use the bigfloat representation at all precisions by turning on the switch <code>roundbf</code>. In rare cases, this switch is turned on by the system, and the user informed by the message</p><pre><code class="nohighlight">        ROUNDBF turned on to increase accuracy</code></pre><p>Rounded numbers are normally printed to the specified precision. However, if the user wishes to print such numbers with less precision, the printing precision can be set by the command <code>print_precision</code>. For example, <code>print_precision(5)</code> will cause such numbers to be printed with five digits maximum.</p><p>Under normal circumstances when <code>rounded</code> is on, REDUCE converts the number <code>1.0</code> to the integer <code>1</code>. If this is not desired, the switch <code>noconvert</code> can be turned on.</p><p>Numbers that are stored internally as bigfloats are normally printed with a space between every five digits to improve readability. If this feature is not required, it can be suppressed by turning off the switch <code>bfspace</code>.</p><p>Further information on the bigfloat arithmetic may be found in T. Sasaki, “Manual for Arbitrary Precision Real Arithmetic System in REDUCE”, Department of Computer Science, University of Utah, Technical Note No. TR-8 (1979).</p><p>When a real number is input, it is normally truncated to the precision in effect at the time the number is read. If it is desired to keep the full precision of all numbers input, the switch <code>adjprec</code> (for adjust precision) can be turned on. While on, <code>adjprec</code> will automatically increase the precision, when necessary, to match that of any integer or real input, and a message printed to inform the user of the precision increase.</p><p>When <code>rounded</code> is on, rational numbers are normally converted to rounded representation. However, if a user wishes to keep such numbers in a rational form until used in an operation that returns a real number, the switch <code>roundall</code> can be turned off. This switch is normally on.</p><p>Results from rounded calculations are returned in rounded form with two exceptions: if the result is recognized as <code>0</code> or <code>1</code> to the current precision, the integer result is returned.</p><h3 id=".11.3-Modular-Number-Coefficients-in-Polynomials"><a class="docs-heading-anchor" href="#.11.3-Modular-Number-Coefficients-in-Polynomials">9.11.3 Modular Number Coefficients in Polynomials</a><a id=".11.3-Modular-Number-Coefficients-in-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.11.3-Modular-Number-Coefficients-in-Polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.setmod" href="#Reduce.Algebra.setmod"><code>Reduce.Algebra.setmod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setmod(::Integer)</code></pre><p>REDUCE includes facilities for manipulating polynomials whose coefficients are computed modulo a given base. To use this option, two commands must be used; <code>R&quot;setmod ⟨integer⟩&quot;</code>, to set the prime modulus, and <code>on(:modular)</code> to cause the actual modular calculations to occur. For example, with <code>R&quot;setmod 3&quot;</code> and <code>R&quot;on modular&quot;</code>, the polynomial <code>(a+2*b)^3</code> would become <code>a^3+2*n^3</code>.</p><p>The argument of <code>setmod</code> is evaluated algebraically, except that non-modular (integer) arithmetic is used. Thus the sequence</p><pre><code class="language-Julia">R&quot;setmod 3; on modular; setmod 7&quot;</code></pre><p>will correctly set the modulus to 7.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L688-L698">source</a></section></article><p>Modular numbers are by default represented by integers in the interval <span>$[0,p-1]$</span> where <span>$p$</span> is the current modulus. Sometimes it is more convenient to use an equivalent symmetric representation in the interval <span>$[-p/2+1,p/2]$</span>, or more precisely <span>$[-floor((p-1)/2), ceiling((p-1)/2)]$</span>, especially if the modular numbers map objects that include negative quantities. The switch <code>balanced_mod</code> allows you to select the symmetric representation for output.</p><p>Users should note that the modular calculations are on the polynomial coefficients only. It is not currently possible to reduce the exponents since no check for a prime modulus is made (which would allow <span>$x^p-1$</span> to be reduced to 1 mod <span>$p$</span>). Note also that any division by a number not co-prime with the modulus will result in the error “Invalid modular division”.</p><h3 id=".11.4-Complex-Number-Coefficients-in-Polynomials"><a class="docs-heading-anchor" href="#.11.4-Complex-Number-Coefficients-in-Polynomials">9.11.4 Complex Number Coefficients in Polynomials</a><a id=".11.4-Complex-Number-Coefficients-in-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#.11.4-Complex-Number-Coefficients-in-Polynomials" title="Permalink"></a></h3><p>Although REDUCE routinely treats the square of the variable <span>$i$</span> as equivalent to -1, this is not sufficient to reduce expressions involving <span>$i$</span> to lowest terms, or to factor such expressions over the complex numbers. For example, in the default case,</p><pre><code class="language-Julia">julia&gt; Algebra.factorize(:(a^2+1))</code></pre><p>gives the result</p><pre><code class="language-Julia">(:(a ^ 2 + 1), 1)</code></pre><p>and</p><pre><code class="nohighlight">        (a^2+b^2)/(a+i*b)</code></pre><p>is not reduced further. However, if the switch <code>complex</code> is turned on, full complex arithmetic is then carried out. In other words, the above factorization will give the result</p><pre><code class="language-Julia">(:(a + im, 1), (a - im, 1))</code></pre><p>and the quotient will be reduced to <code>a-I*b</code>.</p><p>The switch <code>complex</code> may be combined with <code>rounded</code> to give complex real numbers; the appropriate arithmetic is performed in this case.</p><p>Complex conjugation is used to remove complex numbers from denominators of expressions. To do this if <code>complex</code> is off, you must turn the switch <code>rationalize</code> on.</p><h2 id=".12-ROOT_VAL-Operator"><a class="docs-heading-anchor" href="#.12-ROOT_VAL-Operator">9.12 ROOT_VAL Operator</a><a id=".12-ROOT_VAL-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#.12-ROOT_VAL-Operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.root_val" href="#Reduce.Algebra.root_val"><code>Reduce.Algebra.root_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">root_val(exprn)</code></pre><p>The <code>root_val</code> operator takes a single univariate polynomial as argument, and returns a list of root values at system precision (or greater if required to separate roots). It is used with the syntax</p><pre><code class="language-Julia">R&quot;root_val(EXPRN:univariate polynomial)&quot;</code></pre><p>For example, the sequence</p><pre><code class="language-Julia">reduce&gt; on rounded; root_val(x^3-x-1);</code></pre><p>gives the result</p><pre><code class="nohighlight">{0.562279512062*I - 0.662358978622, - 0.562279512062*I  
 
  - 0.662358978622,1.32471795724}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/74f70e1c2b13875dfce720a736cc47b9b0ef084d/src/unary.jl#L700-L717">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../08-display/">« 8 Display and Structuring of Expressions</a><a class="docs-footer-nextpage" href="../10-properties/">10 Assigning and Testing Algebraic Properties »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 14 June 2021 18:34">Monday 14 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
