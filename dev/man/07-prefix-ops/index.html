<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>7 Built-in Prefix Operators · Reduce.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Reduce.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Reduce.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../library/">Library</a></li><li><span class="tocitem">User&#39;s Manual</span><ul><li><a class="tocitem" href="../acknowledgement/">Acknowledgement</a></li><li><a class="tocitem" href="../01-introduction/">1 Introductory Information</a></li><li><a class="tocitem" href="../02-structure/">2 Structure of Programs</a></li><li><a class="tocitem" href="../03-expressions/">3 Expressions</a></li><li><a class="tocitem" href="../04-lists/">4 Lists</a></li><li><a class="tocitem" href="../05-statements/">5 Statements</a></li><li><a class="tocitem" href="../06-commands-declarations/">6 Commands and Declarations</a></li><li class="is-active"><a class="tocitem" href>7 Built-in Prefix Operators</a><ul class="internal"><li><a class="tocitem" href="#.1-Numerical-Operators-1"><span>7.1 Numerical Operators</span></a></li><li><a class="tocitem" href="#.2-Mathematical-Functions-1"><span>7.2 Mathematical Functions</span></a></li><li><a class="tocitem" href="#.3-Bernoulli-Numbers-and-Euler-Numbers-1"><span>7.3 Bernoulli Numbers and Euler Numbers</span></a></li><li><a class="tocitem" href="#.4-Fibonacci-Numbers-and-Fibonacci-Polynomials-1"><span>7.4 Fibonacci Numbers and Fibonacci Polynomials</span></a></li><li><a class="tocitem" href="#.5-Motzkin-numbers-1"><span>7.5 Motzkin numbers</span></a></li><li><a class="tocitem" href="#.6-CHANGEVAR-Operator-1"><span>7.6 CHANGEVAR Operator</span></a></li><li><a class="tocitem" href="#.7-CONTINUED_FRACTION-Operator-1"><span>7.7 CONTINUED_FRACTION Operator</span></a></li><li><a class="tocitem" href="#.8-DF-Operator-1"><span>7.8 DF Operator</span></a></li><li><a class="tocitem" href="#.9-INT-Operator-1"><span>7.9 INT Operator</span></a></li><li><a class="tocitem" href="#.10-LENGTH-Operator-1"><span>7.10 LENGTH Operator</span></a></li><li><a class="tocitem" href="#.11-MAP-Operator-1"><span>7.11 MAP Operator</span></a></li><li><a class="tocitem" href="#.12-MKID-Operator-1"><span>7.12 MKID Operator</span></a></li><li><a class="tocitem" href="#.13-The-Pochhammer-Notation-1"><span>7.13 The Pochhammer Notation</span></a></li><li><a class="tocitem" href="#.14-PF-Operator-1"><span>7.14 PF Operator</span></a></li><li><a class="tocitem" href="#.15-SELECT-Operator-1"><span>7.15 SELECT Operator</span></a></li><li><a class="tocitem" href="#.16-SOLVE-Operator-1"><span>7.16 SOLVE Operator</span></a></li><li><a class="tocitem" href="#.17-Even-and-Odd-Operators-1"><span>7.17 Even and Odd Operators</span></a></li><li><a class="tocitem" href="#.18-Linear-Operators-1"><span>7.18 Linear Operators</span></a></li><li><a class="tocitem" href="#.19-Non-Commuting-Operators-1"><span>7.19 Non-Commuting Operators</span></a></li><li><a class="tocitem" href="#.20-Symmetric-and-Antisymmetric-Operators-1"><span>7.20 Symmetric and Antisymmetric Operators</span></a></li><li><a class="tocitem" href="#.21-Declaring-New-Prefix-Operators-1"><span>7.21 Declaring New Prefix Operators</span></a></li><li><a class="tocitem" href="#.22-Declaring-New-Infix-Operators-1"><span>7.22 Declaring New Infix Operators</span></a></li><li><a class="tocitem" href="#.23-Creating/Removing-Variable-Dependency-1"><span>7.23 Creating/Removing Variable Dependency</span></a></li></ul></li><li><a class="tocitem" href="../08-display/">8 Display and Structuring of Expressions</a></li><li><a class="tocitem" href="../09-polynomials/">9 Polynomials and Rationals</a></li><li><a class="tocitem" href="../10-properties/">10 Assigning and Testing Algebraic Properties</a></li><li><a class="tocitem" href="../11-substitution/">11 Substitution Commands</a></li><li><a class="tocitem" href="../12-file-io/">12 File Handling Commands</a></li><li><a class="tocitem" href="../13-interactive/">13 Commands for Interactive Use</a></li><li><a class="tocitem" href="../14-matrix/">14 Matrix Calculations</a></li><li><a class="tocitem" href="../15-procedures/">15 Procedures</a></li><li><a class="tocitem" href="../16-packages/">16 User Contributed Packages</a></li><li><a class="tocitem" href="../17-symbolic/">17 Symbolic Mode</a></li><li><a class="tocitem" href="../18-physics/">18 Calculations in High Energy Physics</a></li><li><a class="tocitem" href="../19-rlisp/">19 REDUCE and Rlisp Utilities</a></li><li><a class="tocitem" href="../20-maintaining/">20 Maintaining REDUCE</a></li><li><a class="tocitem" href="../A-reserved/">Appendix A: Reserved Identifiers</a></li><li><a class="tocitem" href="../B-bibliography/">Appendix B: Bibliography</a></li><li><a class="tocitem" href="../C-changelog/">Appendix C: Changes since Version 3.8</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User&#39;s Manual</a></li><li class="is-active"><a href>7 Built-in Prefix Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>7 Built-in Prefix Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/07-prefix-ops.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-Prefix-Operators-1"><a class="docs-heading-anchor" href="#Built-in-Prefix-Operators-1">7 Built-in Prefix Operators</a><a class="docs-heading-anchor-permalink" href="#Built-in-Prefix-Operators-1" title="Permalink"></a></h1><p>In the following subsections are descriptions of the most useful prefix operators built into REDUCE that are not defined in other sections (such as substitution operators). Some are fully defined internally as procedures; others are more nearly abstract operators, with only some of their properties known to the system.</p><p>In many cases, an operator is described by a prototypical header line as follows. Each formal parameter is given a name and followed by its allowed type. The names of classes referred to in the definition are printed in lower case, and parameter names in upper case. If a parameter type is not commonly used, it may be a specific set enclosed in brackets <code>{ … }</code>. Operators that accept formal parameter lists of arbitrary length have the parameter and type class enclosed in square brackets indicating that zero or more occurrences of that argument are permitted. Optional parameters and their type classes are enclosed in angle brackets.</p><ul><li><a href="#Built-in-Prefix-Operators-1">7 Built-in Prefix Operators</a></li><ul><li><a href="#.1-Numerical-Operators-1">7.1 Numerical Operators</a></li><li><a href="#.2-Mathematical-Functions-1">7.2 Mathematical Functions</a></li><li><a href="#.3-Bernoulli-Numbers-and-Euler-Numbers-1">7.3 Bernoulli Numbers and Euler Numbers</a></li><li><a href="#.4-Fibonacci-Numbers-and-Fibonacci-Polynomials-1">7.4 Fibonacci Numbers and Fibonacci Polynomials</a></li><li><a href="#.5-Motzkin-numbers-1">7.5 Motzkin numbers</a></li><li><a href="#.6-CHANGEVAR-Operator-1">7.6 CHANGEVAR Operator</a></li><li><a href="#.7-CONTINUED_FRACTION-Operator-1">7.7 CONTINUED_FRACTION Operator</a></li><li><a href="#.8-DF-Operator-1">7.8 DF Operator</a></li><li><a href="#.9-INT-Operator-1">7.9 INT Operator</a></li><li><a href="#.10-LENGTH-Operator-1">7.10 LENGTH Operator</a></li><li><a href="#.11-MAP-Operator-1">7.11 MAP Operator</a></li><li><a href="#.12-MKID-Operator-1">7.12 MKID Operator</a></li><li><a href="#.13-The-Pochhammer-Notation-1">7.13 The Pochhammer Notation</a></li><li><a href="#.14-PF-Operator-1">7.14 PF Operator</a></li><li><a href="#.15-SELECT-Operator-1">7.15 SELECT Operator</a></li><li><a href="#.16-SOLVE-Operator-1">7.16 SOLVE Operator</a></li><li><a href="#.17-Even-and-Odd-Operators-1">7.17 Even and Odd Operators</a></li><li><a href="#.18-Linear-Operators-1">7.18 Linear Operators</a></li><li><a href="#.19-Non-Commuting-Operators-1">7.19 Non-Commuting Operators</a></li><li><a href="#.20-Symmetric-and-Antisymmetric-Operators-1">7.20 Symmetric and Antisymmetric Operators</a></li><li><a href="#.21-Declaring-New-Prefix-Operators-1">7.21 Declaring New Prefix Operators</a></li><li><a href="#.22-Declaring-New-Infix-Operators-1">7.22 Declaring New Infix Operators</a></li><li><a href="#.23-Creating/Removing-Variable-Dependency-1">7.23 Creating/Removing Variable Dependency</a></li></ul></ul><h2 id=".1-Numerical-Operators-1"><a class="docs-heading-anchor" href="#.1-Numerical-Operators-1">7.1 Numerical Operators</a><a class="docs-heading-anchor-permalink" href="#.1-Numerical-Operators-1" title="Permalink"></a></h2><p>REDUCE includes a number of functions that are analogs of those found in most numerical systems. With numerical arguments, such functions return the expected result. However, they may also be called with non-numerical arguments. In such cases, except where noted, the system attempts to simplify the expression as far as it can. In such cases, a residual expression involving the original operator usually remains. These operators are as follows:</p><article class="docstring"><header><a class="docstring-binding" id="AbstractTensors.abs" href="#AbstractTensors.abs"><code>AbstractTensors.abs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abs(r)</code></pre><p><code>abs</code> returns the absolute value of its single argument, if that argument has a numerical value. A non-numerical argument is returned as an absolute value, with an overall numerical coefficient taken outside the absolute value operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.abs(-3/4)
0.75

julia&gt; Algebra.abs(:(2a))
:(2 * abs(a))

julia&gt; Algebra.abs(im)
1.0

julia&gt; Algebra.abs(:(-x))
:(abs(x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L341-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.ceiling" href="#Reduce.Algebra.ceiling"><code>Reduce.Algebra.ceiling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ceiling(r)</code></pre><p>This operator returns the ceiling (i.e., the least integer greater than the given argument) if its single argument has a numerical value. A non-numerical argument is returned as an expression in the original operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.ceiling(-5/4)
-1

julia&gt; Algebra.ceiling(:(-a))
:(ceiling(-a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L361-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractTensors.conj" href="#AbstractTensors.conj"><code>AbstractTensors.conj</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conj(r)</code></pre><p>This operator returns the ceiling (i.e., the least integer greater than the given argument) if its single argument has a numerical value. A non-numerical argument is returned as an expression in the original operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.conj(1+im)
1 - 1im

julia&gt; Algebra.conj(:(a+im*b))
:(repart(a) - ((impart(a) + repart(b)) * im + impart(b)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L375-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.factorial" href="#Reduce.Algebra.factorial"><code>Reduce.Algebra.factorial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">factorial(r)</code></pre><p>If the single argument of <code>factorial</code> evaluates to a non-negative integer, its factorial is returned. Otherwise an expression involving <code>factorial</code> is returned. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.factorial(5)
120

julia&gt; Algebra.factorial(:a)
:(factorial(a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L389-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.fix" href="#Reduce.Algebra.fix"><code>Reduce.Algebra.fix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fix(r)</code></pre><p>This operator returns the fixed value (i.e., the integer part of the given argument) if its single argument has a numerical value. A non-numerical argument is returned as an expression in the original operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.fix(-5/4)
-1

julia&gt; Algebra.fix(:a)
:(fix(a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L403-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.floor" href="#Reduce.Algebra.floor"><code>Reduce.Algebra.floor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floor(r)</code></pre><p>This operator returns the floor (i.e., the greatest integer less than the given argument) if its single argument has a numerical value. A non-numerical argument is returned as an expression in the original operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.floor(-5/4)
-2.0

julia&gt; Algebra.floor(:a)
:(floor(a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L417-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.impart" href="#Reduce.Algebra.impart"><code>Reduce.Algebra.impart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impart(r)</code></pre><p>This operator returns the imaginary part of an expression, if that argument has an numerical value. A non-numerical argument is returned as an expression in the operators <code>repart</code> and <code>impart</code>. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.impart(1+im)
1

julia&gt; Algebra.impart(:(a+im*b))
:(impart(a) + repart(b))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L431-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.max" href="#Reduce.Algebra.max"><code>Reduce.Algebra.max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">max(r...)</code></pre><p><code>max</code> can take an arbitrary number of expressions as their arguments. If all arguments evaluate to numerical values, the maximum of the argument list is returned. If any argument is non-numeric, an appropriately reduced expression is returned. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.max(2,-3,4,5)
5

julia&gt; Algebra.max(:a,2,3)
:(max(3, a))</code></pre><p><code>max</code> of an empty list returns 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L327-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.min" href="#Reduce.Algebra.min"><code>Reduce.Algebra.min</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">min(r...)</code></pre><p><code>min</code> can take an arbitrary number of expressions as their arguments. If all arguments evaluate to numerical values, the minimum of the argument list is returned. If any argument is non-numeric, an appropriately reduced expression is returned. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.min(2,-2)
-2

julia&gt; Algebra.min(:x)
:x</code></pre><p><code>min</code> of an empty list returns 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L343-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.nextprime" href="#Reduce.Algebra.nextprime"><code>Reduce.Algebra.nextprime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextprime(r)</code></pre><p><code>nextprime</code> returns the next prime greater than its integer argument, using a probabilistic algorithm. A type error occurs if the value of the argument is not an integer. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.nextprime(5)
7

julia&gt; Algebra.nextprime(-2)
2

julia&gt; Algebra.nextprime(-7)
-5

julia&gt; Algebra.nextprime(1000000)
1000003</code></pre><p>whereas <code>Algebra.nextprime(:a)</code> gives a type error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L445-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.random" href="#Reduce.Algebra.random"><code>Reduce.Algebra.random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random(r)</code></pre><p><code>random(n)</code> returns a random number <span>$r$</span> in the range <span>$0 ≤ r &lt; n$</span>. A type error occurs if the value of the argument is not a positive integer in algebraic mode, or positive number in symbolic mode. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.random(5)
3

julia&gt; Algebra.random(1000)
191</code></pre><p>whereas <code>Algebra.random(:a)</code> gives a type error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L466-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.random_new_seed" href="#Reduce.Algebra.random_new_seed"><code>Reduce.Algebra.random_new_seed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_new_seed(r)</code></pre><p><code>random_new_seed(n)</code> reseeds the random number generator to a sequence determined by the integer argument <code>n</code>. It can be used to ensure that a repeatable pseudo-random sequence will be delivered regardless of any previous use of <code>random</code>, or can be called early in a run with an argument derived from something variable (such as the time of day) to arrange that different runs of a REDUCE program will use different random sequences. When a fresh copy of REDUCE is first created it is as if <code>random_new_seed(1)</code> has been obeyed.</p><p>A type error occurs if the value of the argument is not a positive integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L482-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.repart" href="#Reduce.Algebra.repart"><code>Reduce.Algebra.repart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repart(r)</code></pre><p>This returns the real part of an expression, if that argument has an numerical value. A non-numerical argument is returned as an expression in the operators <code>repart</code> and <code>impart</code>. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.repart(1+im)
1

julia&gt; Algebra.repart(:(a+im*b))
:(repart(a) - impart(b))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L490-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.round" href="#Reduce.Algebra.round"><code>Reduce.Algebra.round</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">round(r)</code></pre><p>This operator returns the rounded value (i.e, the nearest integer) of its single argument if that argument has a numerical value. A non-numeric argument is returned as an expression in the original operator. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.round(-5/4)
-1.0

julia&gt; Algebra.round(:a)
:(round(a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L504-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.sign" href="#Reduce.Algebra.sign"><code>Reduce.Algebra.sign</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sign(r)</code></pre><p><code>sign</code> tries to evaluate the sign of its argument. If this is possible <code>sign</code> returns one of <code>1</code>, <code>0</code> or <code>-1</code>. Otherwise, the result is the original form or a simplified variant. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.sign(-5)
-1

julia&gt; Algebra.sign(:(-a^2*b))
:(-(sign(b)))</code></pre><p>Note that even powers of formal expressions are assumed to be positive only as long as the switch <code>complex</code> is off.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L518-L531">source</a></section></article><h2 id=".2-Mathematical-Functions-1"><a class="docs-heading-anchor" href="#.2-Mathematical-Functions-1">7.2 Mathematical Functions</a><a class="docs-heading-anchor-permalink" href="#.2-Mathematical-Functions-1" title="Permalink"></a></h2><p>REDUCE knows that the following represent mathematical functions that can take arbitrary scalar expressions as their argument(s):</p><pre><code class="language-none">acos acosh acot acoth acsc acsch asec asech asin  
asinh atan atanh atan2 beta ci cos cosh cot coth csc  
csch dilog ei exp gamma hypot ibeta igamma ln log  
logb log10 sec sech si sin sinh sqrt tan tanh  
airy_ai airy_aiprime airy_bi airy_biprime  
besseli besselj besselk bessely  
hankel1 hankel2 kummerm kummeru lommel1 lommel2  
struveh struvel whittakerm whittakeru  
polygamma psi zeta  
solidharmonicy sphericalharmonicy</code></pre><p>where <code>log</code> is the natural logarithm (and equivalent to <code>ln</code>), and <code>logb</code> has two arguments of which the second is the logarithmic base.</p><p>The derivatives of all these functions are also known to the system.</p><p>REDUCE knows various elementary identities and properties of these functions. For example:</p><blockquote><pre><code class="language-none"> cos(-x) = cos(x)              sin(-x) = - sin (x)  
 cos(n*pi) = (-1)^n            sin(n*pi) = 0  
 log(e)  = 1                   e^(i*pi/2) = i  
 log(1)  = 0                   e^(i*pi) = -1  
 log(e^x) = x                  e^(3*i*pi/2) = -i</code></pre></blockquote><p>Beside these identities, there are a lot of simplifications for elementary functions defined in the REDUCE system as rulelists. In order to view these, the <code>showrules</code> operator can be used, e.g.</p><pre><code class="language-Julia">reduce&gt; showrules tan;  
 
{tan(~n*arbint(~i)*pi + ~(~ x)) =&gt; tan(x) when fixp(n),  
 
 tan(~x)  
 
  =&gt; trigquot(sin(x),cos(x)) when knowledge_about(sin,x,tan),  
 
      ~x + ~(~ k)*pi  
 tan(----------------)  
            ~d  
 
             x                  k                     k     1  
  =&gt;  - cot(---) + i*pi*impart(---)) when abs(repart(---))=---,  
             d                  d                     d     2  
 
      ~(~ w) + ~(~ k)*pi           w      k                k  
 tan(--------------------) =&gt; tan(--- + (--- - fix(repart(---)))*pi)  
            ~(~ d)                 d      d                d  
 
                              k  
 when whereexp({rp =&gt; repart(---)},bool-eval(ratnump(rp) and abs(rp)&gt;=1)),  
                              d  
 
 tan(atan(~x)) =&gt; x,  
 
                             2  
 df(tan(~x),~x) =&gt; 1 + tan(x) }  
</code></pre><p>For further simplification, especially of expressions involving trigonometric functions, see the TRIGSIMP package (chapter 16.72) documentation.</p><p>Functions not listed above may be defined in the special functions package SPECFN.</p><p>The user can add further rules for the reduction of expressions involving these operators by using the <code>let</code> command.</p><p>In many cases it is desirable to expand product arguments of logarithms, or collect a sum of logarithms into a single logarithm. Since these are inverse operations, it is not possible to provide rules for doing both at the same time and preserve the REDUCE concept of idempotent evaluation. As an alternative, REDUCE provides two switches <code>expandlogs</code> and <code>combinelogs</code> to carry out these operations. Both are off by default, and are subject to the value of the switch <code>precise</code>. This switch is on by default and prevents modifications that may be false in a complex domain. Thus to expand <code>log(3*y)</code> into a sum of logs, one can say</p><pre><code class="language-Julia">julia&gt; Algebra.on(:expandlogs);

julia&gt; Algebra.log(:(3*y))</code></pre><p>whereas to expand <code>log(x*y)</code> into a sum of logs, one needs to say</p><pre><code class="language-Julia">julia&gt; Algebra.off(:precise); Algebra.on(:expandlogs);

julia&gt; Algebra.log(:(x*y))</code></pre><p>To combine this sum into a single log:</p><pre><code class="language-Julia">julia&gt; Algebra.off(:precise); Algebra.on(:combinelogs);

julia&gt; Alebra.:+(log(:x),log(:y))</code></pre><p>These switches affect the logarithmic functions <code>log10</code> (base 10) and <code>logb</code> (arbitrary base) as well.</p><p>At the present time, it is possible to have both switches on at once, which could lead to infinite recursion. However, an expression is switched from one form to the other in this case. Users should not rely on this behavior, since it may change in the next release.</p><p>The current version of REDUCE does a poor job of simplifying surds. In particular, expressions involving the product of variables raised to non-integer powers do not usually have their powers combined internally, even though they are printed as if those powers were combined. For example, the expression</p><pre><code class="language-Julia">reduce&gt; x^(1/3)*x^(1/6)</code></pre><p>will print as</p><pre><code class="language-none">sqrt(x)</code></pre><p>but will have an internal form containing the two exponentiated terms. If you now subtract <code>sqrt(x)</code> from this expression, you will not get zero. Instead, the confusing form</p><pre><code class="language-none">sqrt(x) - sqrt(x)</code></pre><p>will result. To combine such exponentiated terms, the switch <code>combineexpt</code> should be turned on.</p><p>The square root function can be input using the name <code>sqrt</code>, or the power operation <code>^(1/2)</code>. On output, unsimplified square roots are normally represented by the operator <code>sqrt</code> rather than a fractional power. With the default system switch settings, the argument of a square root is first simplified, and any divisors of the expression that are perfect squares taken outside the square root argument. The remaining expression is left under the square root. Thus the expression</p><pre><code class="language-Julia">julia&gt; Algebra.sqrt(:(-8a^2*b))</code></pre><p>becomes</p><pre><code class="language-Julia">:(2 * sqrt(b) * sqrt(2) * a * im)</code></pre><p>Note that such simplifications can cause trouble if A is eventually given a value that is a negative number. If it is important that the positive property of the square root and higher even roots always be preserved, the switch PRECISE should be set on (the default value). This causes any non-numerical factors taken out of surds to be represented by their absolute value form. With PRECISE on then, the above example would become</p><pre><code class="language-Julia">:(2 * sqrt(-2b) * abs(a))</code></pre><p>However, this is incorrect in the complex domain, where the <span>$\sqrt{x^2}$</span> is not identical to <span>$|x|$</span>. To avoid the above simplification, the switch <code>precise_complex</code> should be set on (default is off). For example:</p><pre><code class="language-Julia">julia&gt; Algebra.on(:precise_complex); Algebra.sqrt(:(-8a^2*b))</code></pre><p>yields the output</p><pre><code class="language-Julia">:(2 * sqrt(-2 * a ^ 2 * b))</code></pre><p>The statement that REDUCE knows very little about these functions applies only in the mathematically exact off rounded mode. If <code>rounded</code> is on, any of the functions</p><pre><code class="language-none">acos acosh acot acoth acsc acsch asec asech asin  
asinh atan atanh atan2 cos cosh cot coth csc csch  
exp hypot ibeta igamma ln log logb log10 psi sec  
sech sin sinh sqrt tan tanh</code></pre><p>when given a numerical argument has its value calculated to the current degree of floating point precision. In addition, real (non-integer valued) powers of numbers will also be evaluated.</p><p>If the <code>complex</code> switch is turned on in addition to <code>rounded</code>, these functions will also calculate a real or complex result, again to the current degree of floating point precision, if given complex arguments. For example,</p><pre><code class="language-Julia">julia&gt; @rounded @complex 2.3^(5.6im)
:(-0.0480793490914 - 0.998843519372im)

julia&gt; @rounded @complex cos(2+3im)
:(-4.18962569097 - 9.10922789376im)</code></pre><h2 id=".3-Bernoulli-Numbers-and-Euler-Numbers-1"><a class="docs-heading-anchor" href="#.3-Bernoulli-Numbers-and-Euler-Numbers-1">7.3 Bernoulli Numbers and Euler Numbers</a><a class="docs-heading-anchor-permalink" href="#.3-Bernoulli-Numbers-and-Euler-Numbers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.bernoulli" href="#Reduce.Algebra.bernoulli"><code>Reduce.Algebra.bernoulli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bernoulli(n)</code></pre><p>The unary operator <code>bernoulli</code> provides notation and computation for Bernoulli numbers. <code>bernoulli(n)</code> evaluates to the <code>n</code>th Bernoulli number; all of the odd Bernoulli numbers, except <code>bernoulli(1)</code>, are zero.</p><p>The algorithms are based upon those by Herbert Wilf, presented by Sandra Fillebrown [?]. If the <code>rounded</code> switch is off, the algorithms are exactly those; if it is on, some further rounding may be done to prevent computation of redundant digits. Hence, these functions are particularly fast when used to approximate the Bernoulli numbers in rounded mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L533-L539">source</a></section></article><p>Euler numbers are computed by the unary operator Euler, which return the nth Euler number. The computation is derived directly from Pascal’s triangle of binomial coefficients.</p><h2 id=".4-Fibonacci-Numbers-and-Fibonacci-Polynomials-1"><a class="docs-heading-anchor" href="#.4-Fibonacci-Numbers-and-Fibonacci-Polynomials-1">7.4 Fibonacci Numbers and Fibonacci Polynomials</a><a class="docs-heading-anchor-permalink" href="#.4-Fibonacci-Numbers-and-Fibonacci-Polynomials-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.fibonacci" href="#Reduce.Algebra.fibonacci"><code>Reduce.Algebra.fibonacci</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fibonacci(n)</code></pre><p>The unary operator <code>fibonacci</code> provides notation and computation for Fibonacci numbers. <code>fibonacci(n)</code> evaluates to the <code>n</code>th Fibonacci number. If <code>n</code> is a positive or negative integer, it will be evaluated following the definition:</p><div>\[F_0 = 0; F_1 = 1; F_n = F_{n-1} + F_{n-2}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L541-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.fibonaccip" href="#Reduce.Algebra.fibonaccip"><code>Reduce.Algebra.fibonaccip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fibonacci(n,x)</code></pre><p>Fibonacci Polynomials are computed by the binary operator <code>fibonaccip</code>. <code>fibonaccip(n,x)</code> returns the <code>n</code>th Fibonacci polynomial in the variable <code>x</code>. If <code>n</code> is a positive or negative integer, it will be evaluated following the definition:</p><div>\[F_0(x) = 0; F_1(x) = 1; F_n(x) = xF_{n-1}(x) + F_{n-2}(x)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L624-L630">source</a></section></article><h2 id=".5-Motzkin-numbers-1"><a class="docs-heading-anchor" href="#.5-Motzkin-numbers-1">7.5 Motzkin numbers</a><a class="docs-heading-anchor-permalink" href="#.5-Motzkin-numbers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.motzkin" href="#Reduce.Algebra.motzkin"><code>Reduce.Algebra.motzkin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">motzkin(n)</code></pre><p>A Motzkin number <span>$M_n$</span> (named after Theodore Motzkin) is the number of different ways of drawing non-intersecting chords on a circle between n points. For a non-negative integer <code>n</code>, the operator <code>motzkin(n)</code> returns the <code>n</code>th Motzkin number, according to the recursion formula</p><div>\[M_0 =  1;  M_1 = 1;  M_{n+1}  =  \frac{2n+3}{n+3}M_n + \frac{3n}{n+3}M_{n-1}.\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L549-L555">source</a></section></article><h2 id=".6-CHANGEVAR-Operator-1"><a class="docs-heading-anchor" href="#.6-CHANGEVAR-Operator-1">7.6 CHANGEVAR Operator</a><a class="docs-heading-anchor-permalink" href="#.6-CHANGEVAR-Operator-1" title="Permalink"></a></h2><p>Author: G. Üçoluk.</p><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.changevar" href="#Reduce.Algebra.changevar"><code>Reduce.Algebra.changevar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">changevar(depvars,newvars,eqlist,diffeq)</code></pre><p>The operator <code>changevar</code> does a variable transformation in a set of differential equations. Syntax:</p><pre><code class="language-none">changevar(⟨depvars⟩,⟨newvars⟩,⟨eqlist⟩,⟨diffeq⟩)</code></pre><p><code>⟨diffeq⟩</code> is either a single differential equation or a list of differential equations, <code>⟨depvars⟩</code> are the dependent variables to be substituted, <code>⟨newvars⟩</code> are the new depend variables, and <code>⟨eqlist⟩</code> is a list of equations of the form <code>⟨depvar⟩=⟨expression⟩</code> where <code>⟨expression⟩</code> is some function in the new dependent variables.</p><p>The three lists <code>⟨depvars⟩</code>, <code>⟨newvars⟩</code>, and <code>⟨eqlist⟩</code> must be of the same length. If there is only one variable to be substituted, then it can be given instead of the list. The same applies to the list of differential equations, i.e., the following two commands are equivalent</p><pre><code class="language-Julia">Algebra.operator(:u)
Algebra.changevar(:u,:y,:(x==e^y),:(df(u(x),x) - log(x)))
Algebra.changevar((:u,),(:y,),(:(x=e^y),),(:(df(u(x),x) - log(x)),))</code></pre><p>except for one difference: the first command returns the transformed differential equation, the second one a list with a single element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L1090-L1106">source</a></section></article><p>The switch <code>dispjacobian</code> governs the display the entries of the inverse Jacobian, it is <code>off</code> per default.</p><p>The mathematics behind the change of independent variable(s) in differential equations is quite straightforward. It is basically the application of the chain rule. If the dependent variable of the differential equation is <span>$F$</span> , the independent variables are <span>$x_i$</span> and the new independent variables are <span>$u_i$</span> (where <span>$i=1…n$</span>) then the first derivatives are: <span>$\frac{-\partial F}{\partial x_i} =  \frac{\partial F}{\partial u_j} \frac{\partial u_j}{\partial x_i}$</span></p><p>We assumed Einstein’s summation convention. Here the problem is to calculate the <span>$∂u_j∕∂x_i$</span> terms if the change of variables is given by <span>$x_i = f_i (u_1 ,...,u_n  ).$</span></p><p>The first thought might be solving the above given equations for <span>$u_j$</span> and then differentiating them with respect to <span>$x_i$</span>, then again making use of the equations above, substituting new variables for the old ones in the calculated derivatives. This is not always a preferable way to proceed. Mainly because the functions <span>$f_i$</span> may not always be easily invertible. Another approach that makes use of the Jacobian is better. Consider the above given equations which relate the old variables to the new ones. Let us differentiate them:</p><div>\[\frac{\partial x_j}{\partial x_i} = \frac{\partial f_j}{\partial x_i}\]</div><div>\[\delta_{ij} = \frac{\partial f_j \partial u_k}{\partial u_k \partial x_i}\]</div><p>The first derivative is nothing but the <span>$(j,k)$</span> th entry of the Jacobian matrix.</p><p>So if we speak in matrix language <span>$1 = J ⋅ D$</span> where we defined the Jacobian <span>$J_{ij} = \frac{\partial f_i}{\partial u_j}$</span> and the matrix of the derivatives we wanted to obtain as <span>$D_{ij} = \frac{\partial u_i}{\partial x_j}.$</span> If the Jacobian has a non-vanishing determinant then it is invertible and we are able to write from the matrix equation above: <span>$D =  J^{-1}$</span> so finally we have what we want <span>$\frac{\partial u_i}{\partial x_j} = [ J^{-1} ]_{ij}$</span></p><p>The higher derivatives are obtained by the successive application of the chain rule and using the definitions of the old variables in terms of the new ones. It can be easily verified that the only derivatives that are needed to be calculated are the first order ones which are obtained above.</p><h3 id=".6.1-CHANGEVAR-example:-The-2-dim.-Laplace-Equation-1"><a class="docs-heading-anchor" href="#.6.1-CHANGEVAR-example:-The-2-dim.-Laplace-Equation-1">7.6.1 CHANGEVAR example: The 2-dim. Laplace Equation</a><a class="docs-heading-anchor-permalink" href="#.6.1-CHANGEVAR-example:-The-2-dim.-Laplace-Equation-1" title="Permalink"></a></h3><p>The 2-dimensional Laplace equation in cartesian coordinates is: <span>$\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = 0$</span> Now assume we want to obtain the polar coordinate form of Laplace equation. The change of variables is: <span>$x = r\cos θ,    y = r\sin θ$</span> The solution using <code>changevar</code> is as follows</p><pre><code class="language-Julia">Algebra.changevar((:u,),(:r,:θ),(:(x=r*cos(θ)),:(y=r*sin(θ))),
            (:(df(u(x,y),x,2)+df(u(x,y),y,2)),) )</code></pre><p>Here we could omit the list parenthesis in the first and last arguments (because those lists have only one member) and the list parenthesis in the third argument (because they are optional), but you cannot leave off the list parenthesis in the second argument. So one could equivalently write</p><pre><code class="language-Julia">Algebra.changevar(:u,(:r,:θ),:(x==r*cos(θ)),:(y==r*sin(θ)),  
             :(df(u(x,y),x,2)+df(u(x,y),y,2)) )</code></pre><p>If you have tried out the above example, you will notice that the denominator contains a <span>$\cos^2θ + \sin^2θ$</span> which is actually equal to 1. This has of course nothing to do with <code>changevar</code>. One has to be overcome these pattern matching problems by the conventional methods REDUCE provides (a rule, for example, will fix it).</p><p>Secondly you will notice that your <code>u(x,y)</code> operator has changed to <code>u(r,θ)</code> in the result. Nothing magical about this. That is just what we do with pencil and paper. <code>u(r,θ)</code> represents the the transformed dependent variable.</p><h3 id=".6.2-Another-CHANGEVAR-example:-An-Euler-Equation-1"><a class="docs-heading-anchor" href="#.6.2-Another-CHANGEVAR-example:-An-Euler-Equation-1">7.6.2 Another CHANGEVAR example: An Euler Equation</a><a class="docs-heading-anchor-permalink" href="#.6.2-Another-CHANGEVAR-example:-An-Euler-Equation-1" title="Permalink"></a></h3><p>Consider a differential equation which is of Euler type, for instance: <span>$x^3y ′′′ - 3x^2y′′ + 6xy ′ - 6y = 0$</span> where prime denotes differentiation with respect to <span>$x$</span>. As is well known, Euler type of equations are solved by a change of variable: <span>$x = e^u.$</span> So our call to <code>changevar</code> reads as follows:</p><pre><code class="language-Julia">Algebra.changevar(:y, :u, :(x==e^u), :(x^3*df(y(x),x,3)-  
             3*x^2*df(y(x),x,2)+6*x*df(y(x),x)-6*y(x)))</code></pre><p>and returns the result</p><pre><code class="language-Julia">:(((11 * df(y(u), u) - 6 * y(u)) - 6 * df(y(u), u, 2)) + df(y(u), u, 3))</code></pre><h2 id=".7-CONTINUED_FRACTION-Operator-1"><a class="docs-heading-anchor" href="#.7-CONTINUED_FRACTION-Operator-1">7.7 CONTINUED_FRACTION Operator</a><a class="docs-heading-anchor-permalink" href="#.7-CONTINUED_FRACTION-Operator-1" title="Permalink"></a></h2><p>Not initially supported by Reduce.jl parser, see <a href="http://www.reduce-algebra.com/manual/manualse33.html">upstream docs</a> for more information.</p><h2 id=".8-DF-Operator-1"><a class="docs-heading-anchor" href="#.8-DF-Operator-1">7.8 DF Operator</a><a class="docs-heading-anchor-permalink" href="#.8-DF-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.df" href="#Reduce.Algebra.df"><code>Reduce.Algebra.df</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">df(r...)</code></pre><p>The operator <code>df</code> is used to represent partial differentiation with respect to one or more variables. It is used with the syntax:</p><pre><code class="language-Julia">R&quot;df(⟨EXPRN:algebraic⟩[,⟨VAR:kernel⟩ &lt;,⟨NUM:integer⟩ &gt;])&quot;</code></pre><p>The first argument is the expression to be differentiated. The remaining arguments specify the differentiation variables and the number of times they are applied.</p><p>The number <code>num</code> may be omitted if it is <code>1</code>. For example,</p><pre><code class="language-Julia">reduce&gt; df(y,x)

reduce&gt; df(y,x,2)

reduce&gt; df(y,x1,2,x2,x3,2)</code></pre><p>The evaluation of <code>df(y,x)</code> proceeds as follows: first, the values of <code>y</code> and <code>x</code> are found. Let us assume that <code>x</code> has no assigned value, so its value is <code>x</code>. Each term or other part of the value of <code>y</code> that contains the variable <code>x</code> is differentiated by the standard rules. If <code>z</code> is another variable, not <code>x</code> itself, then its derivative with respect to <code>x</code> is taken to be <code>0</code>, unless <code>z</code> has previously been declared to <code>depend</code> on <code>x</code>, in which case the derivative is reported as the symbol <code>df(z,x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L359-L377">source</a></section></article><h3 id=".8.1-Switches-influencing-differentiation-1"><a class="docs-heading-anchor" href="#.8.1-Switches-influencing-differentiation-1">7.8.1 Switches influencing differentiation</a><a class="docs-heading-anchor-permalink" href="#.8.1-Switches-influencing-differentiation-1" title="Permalink"></a></h3><p>Consider <code>df(u,x,y,z)</code>. If none of <code>x</code>,<code>y</code>,<code>z</code> are equal to <code>u</code> then the order of differentiation is commuted into a canonical form, unless the switch <code>nocommutedf</code> is turned on (default is off). if at least one of <code>x</code>,<code>y</code>,<code>z</code> is equal to <code>u</code> then the order of differentiation is not commuted and the derivative is not simplified to zero, unless the switch <code>commutedf</code> is turned on. It is off by default.</p><p>If <code>commutedf</code> is off and the switch <code>simpnoncomdf</code> is on then simplify as follows:</p><pre><code class="language-none">df(u,x,u)        -&gt;  df(u,x,2) / df(u,x)  
df(u,x,n,u)      -&gt;  df(u,x,n+1) / df(u,x)</code></pre><p>provided <code>u</code> depends only on the one variable <code>x</code>. This simplification removes the non-commutative aspect of the derivative.</p><p>If the switch <code>expanddf</code> is turned on then REDUCE uses the chain rule to expand symbolic derivatives of indirectly dependent variables provided the result is unambiguous, i.e. provided there is no direct dependence. It is off by default. Thus, for example, given</p><pre><code class="language-Julia">julia&gt; Algebra.depend(:f,:u,:v); Algebra.depend((:u,:v),:x)

julia&gt; Algebra.on(:expanddf)

julia&gt; Algebra.df(:f,:x)
:(df(f, u) * df(u, x) + df(f, v) * df(v, x))</code></pre><p>whereas after</p><pre><code class="language-Julia">julia&gt; Algebra.depend(:f,:x)</code></pre><p><code>df(:f,:x)</code> does not expand at all (since the result would be ambiguous and the algorithm would loop).</p><p>Turning on the switch <code>allowdfint</code> allows “differentiation under the integral sign”, i.e.</p><pre><code class="language-none">df(int(y, x), v) -&gt; int(df(y, v), x)</code></pre><p>if this results in a simplification. If the switch <code>dfint</code> is also turned on then this happens regardless of whether the result simplifies. Both switches are off by default.</p><h3 id=".8.2-Adding-Differentiation-Rules-1"><a class="docs-heading-anchor" href="#.8.2-Adding-Differentiation-Rules-1">7.8.2 Adding Differentiation Rules</a><a class="docs-heading-anchor-permalink" href="#.8.2-Adding-Differentiation-Rules-1" title="Permalink"></a></h3><p>The <code>let</code> statement can be used to introduce rules for differentiation of user-defined operators. Its general form is</p><pre><code class="language-Julia">R&quot;for all ⟨var1⟩,…,⟨varn⟩ let df(⟨operator⟩⟨varlist⟩,⟨vari⟩)=⟨expression⟩&quot;</code></pre><p>where <code>⟨varlist⟩ ::= (⟨var1⟩,…,⟨varn⟩)</code>, and <code>⟨var1⟩,…,⟨varn⟩</code> are the dummy variable arguments of <code>⟨operator⟩</code>.</p><p>An analogous form applies to infix operators.</p><p><em>Examples:</em></p><pre><code class="language-Julia">R&quot;for all x let df(tan x,x)= 1 + tan(x)^2&quot;</code></pre><p>(This is how the tan differentiation rule appears in the REDUCE source.)</p><pre><code class="language-Julia">R&quot;for all x,y let df(f(x,y),x)=2*f(x,y),  df(f(x,y),y)=x*f(x,y)&quot;</code></pre><p>Notice that all dummy arguments of the relevant operator must be declared arbitrary by the <code>for all</code> command, and that rules may be supplied for operators with any number of arguments. If no differentiation rule appears for an argument in an operator, the differentiation routines will return as result an expression in terms of <code>df</code>. For example, if the rule for the differentiation with respect to the second argument of <code>f</code> is not supplied, the evaluation of <code>df(f(x,z),z)</code> would leave this expression unchanged. (No <code>depend</code> declaration is needed here, since <code>f(x,z)</code> obviously “depends on” <code>z</code>.)</p><p>Once such a rule has been defined for a given operator, any future differentiation rules for that operator must be defined with the same number of arguments for that operator, otherwise we get the error message</p><pre><code class="language-Julia">ERROR: Reduce: 
Incompatible df rule argument length for &lt;operator&gt;</code></pre><h2 id=".9-INT-Operator-1"><a class="docs-heading-anchor" href="#.9-INT-Operator-1">7.9 INT Operator</a><a class="docs-heading-anchor-permalink" href="#.9-INT-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.int" href="#Reduce.Algebra.int"><code>Reduce.Algebra.int</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">int(r...)</code></pre><p><code>int</code> is an operator in REDUCE for indefinite integration using a combination of the Risch-Norman algorithm and pattern matching. It is used with the syntax:</p><pre><code class="language-Julia">R&quot;int(⟨EXPRN:algebraic⟩,⟨VAR:kernel⟩)&quot;</code></pre><p>This will return correctly the indefinite integral for expressions comprising polynomials, log functions, exponential functions and tan and atan. The arbitrary constant is not represented. If the integral cannot be done in closed terms, it returns a formal integral for the answer in one of two ways:</p><ol><li>It returns the input, <code>int(…,…)</code> unchanged.</li><li>It returns an expression involving <code>int</code>s of some other functions (sometimes more complicated than the original one, unfortunately).</li></ol><p>Rational functions can be integrated when the denominator is factorizable by the program. In addition it will attempt to integrate expressions involving error functions, dilogarithms and other trigonometric expressions. In these cases it might not always succeed in finding the solution, even if one exists.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.int(:(log(x)),:x)
:((log(x) - 1) * x)

julia&gt; Algebra.int(:(e^x),:x)
:(e ^ x)</code></pre><p>The program checks that the second argument is a variable and gives an error if it is not.</p><p><em>Note:</em> If the <code>int</code> operator is called with 4 arguments, REDUCE will implicitly call the definite integration package (DEFINT) and this package will interpret the third and fourth arguments as the lower and upper limit of integration, respectively. For details, consult the documentation on the DEFINT package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L379-L404">source</a></section></article><h3 id=".9.1-Options-1"><a class="docs-heading-anchor" href="#.9.1-Options-1">7.9.1 Options</a><a class="docs-heading-anchor-permalink" href="#.9.1-Options-1" title="Permalink"></a></h3><p>The switch <code>trint</code> when on will trace the operation of the algorithm. It produces a great deal of output in a somewhat illegible form, and is not of much interest to the general user. It is normally off.</p><p>The switch <code>trintsubst</code> when on will trace the heuristic attempts to solve the integral by substitution. It is normally off.</p><p>If the switch <code>failhard</code> is on the algorithm will terminate with an error if the integral cannot be done in closed terms, rather than return a formal integration form. <code>failhard</code> is normally off.</p><p>The switch <code>nolnr</code> suppresses the use of the linear properties of integration in cases when the integral cannot be found in closed terms. It is normally off.</p><p>The switch <code>nointsubst</code> disables the heuristic attempts to solve the integral by substitution. It is normally off.</p><h3 id=".9.2-Advanced-Use-1"><a class="docs-heading-anchor" href="#.9.2-Advanced-Use-1">7.9.2 Advanced Use</a><a class="docs-heading-anchor-permalink" href="#.9.2-Advanced-Use-1" title="Permalink"></a></h3><p>If a function appears in the integrand that is not one of the functions <code>exp</code>, <code>erf</code>, <code>tan</code>, <code>atan</code>, <code>log</code>, <code>dilog</code> then the algorithm will make an attempt to integrate the argument if it can, differentiate it and reach a known function. However the answer cannot be guaranteed in this case. If a function is known to be algebraically independent of this set it can be flagged transcendental by</p><pre><code class="language-Julia">R&quot;flag(’(trilog),’transcendental)&quot;</code></pre><p>in which case this function will be added to the permitted field descriptors for a genuine decision procedure. If this is done the user is responsible for the mathematical correctness of his actions.</p><p>The standard version does not deal with algebraic extensions. Thus integration of expressions involving square roots and other like things can lead to trouble. A contributed package that supports integration of functions involving square roots is available, however (ALGINT, chapter 16.1). In addition there is a definite integration package, DEFINT( chapter 16.18).</p><h3 id=".9.3-References-1"><a class="docs-heading-anchor" href="#.9.3-References-1">7.9.3 References</a><a class="docs-heading-anchor-permalink" href="#.9.3-References-1" title="Permalink"></a></h3><p>A. C. Norman &amp; P. M. A. Moore, “Implementing the New Risch Algorithm”, Proc. 4th International Symposium on Advanced Comp. Methods in Theor. Phys., CNRS, Marseilles, 1977.</p><p>S. J. Harrington, “A New Symbolic Integration System in Reduce”, Comp. Journ. 22 (1979) 2.</p><p>A. C. Norman &amp; J. H. Davenport, “Symbolic Integration — The Dust Settles?”, Proc. EUROSAM 79, Lecture Notes in Computer Science 72, Springer-Verlag, Berlin Heidelberg New York (1979) 398-407.</p><h2 id=".10-LENGTH-Operator-1"><a class="docs-heading-anchor" href="#.10-LENGTH-Operator-1">7.10 LENGTH Operator</a><a class="docs-heading-anchor-permalink" href="#.10-LENGTH-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.length" href="#Reduce.Algebra.length"><code>Reduce.Algebra.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">length(r)</code></pre><p><code>length</code> is a generic operator for finding the length of various objects in the system. The meaning depends on the type of the object. In particular, the length of an algebraic expression is the number of additive top-level terms its expanded representation.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; length(:(a+b))
2

julia&gt; length(2)
1</code></pre><p>Other objects that support a length operator include arrays, lists and matrices. The explicit meaning in these cases is included in the description of these objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/unary.jl#L186-L200">source</a></section></article><h2 id=".11-MAP-Operator-1"><a class="docs-heading-anchor" href="#.11-MAP-Operator-1">7.11 MAP Operator</a><a class="docs-heading-anchor-permalink" href="#.11-MAP-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.map" href="#Reduce.Algebra.map"><code>Reduce.Algebra.map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map(fnc,obj)</code></pre><p>The <code>map</code> operator applies a uniform evaluation pattern to all members of a composite structure: a matrix, a list, or the arguments of an operator expression. The evaluation pattern can be a unary procedure, an operator, or an algebraic expression with one free variable.</p><p>It is used with the syntax:</p><pre><code class="language-none">   map(FNC:function,OBJ:object)</code></pre><p>Here <code>OBJ</code> is a list, a matrix or an operator expression. <code>FNC</code> can be one of the following:</p><ol><li>the name of an operator with a single argument: the operator is evaluated once with each element of <code>OBJ</code> as its single argument;</li><li>an algebraic expression with exactly one free variable, i.e. a variable preceded by the tilde symbol. The expression is evaluated for each element of <code>OBJ</code>, with the element substituted for the free variable;</li><li>a replacement rule of the form <code>var =&gt; rep</code> where <code>var</code> is a variable (a kernel without a subscript) and <code>rep</code> is an expression that contains <code>var</code>. The replacement expression <code>rep</code> is evaluated for each element of <code>OBJ</code> with the element substituted for <code>var</code>. The variable <code>var</code> may be optionally preceded by a tilde.</li></ol><p>The rule form for <code>FNC</code> is needed when more than one free variable occurs.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.map(:abs, (1,-2,:a,:(-a)))
(1, 2, :(abs(a)), :(abs(a)))

julia&gt; Algebra.map(:(int(~w,x)), [:(x^2) :(x^5); :(x^4) :(x^5)])
2×2 Array{Any,2}:
 :(x ^ 3 // 3)  :(x ^ 6 // 6)
 :(x ^ 5 // 5)  :(x ^ 6 // 6)

 julia&gt; Algebra.map(:(~w*6), :(x^2/3 == y^3/2 -1))
:(2 * x ^ 2 = 3 * (y ^ 3 - 2))</code></pre><p>You can use <code>map</code> in nested expressions. However, you cannot apply <code>map</code> to a non-composite object, e.g. an identifier or a number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L1108-L1139">source</a></section></article><h2 id=".12-MKID-Operator-1"><a class="docs-heading-anchor" href="#.12-MKID-Operator-1">7.12 MKID Operator</a><a class="docs-heading-anchor-permalink" href="#.12-MKID-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.mkid" href="#Reduce.Algebra.mkid"><code>Reduce.Algebra.mkid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mkid(u,v)</code></pre><p>In many applications, it is useful to create a set of identifiers for naming objects in a consistent manner. In most cases, it is sufficient to create such names from two components. The operator <code>mkid</code> is provided for this purpose. Its syntax is:</p><pre><code class="language-Julia">R&quot;mkid(U:id,V:id|non-negative integer)&quot;</code></pre><p>for example</p><pre><code class="language-Julia">julia&gt; Algebra.mkid(:a,3)
:a3

julia&gt; Algebra.mkid(:apple,:s)
:apples</code></pre><p>while <code>mkid(:(a+b),2)</code> gives an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L632-L648">source</a></section></article><p>The <code>set</code> statement can be used to give a value to the identifiers created by <code>mkid</code>, for example</p><pre><code class="language-Julia">julia&gt; Algebra.set(Algebra.mkid(:a,3),2)</code></pre><p>will give <code>a3</code> the value 2. Similarly, the <code>unset</code> statement can be used to remove the value from these identifiers, for example</p><pre><code class="language-Julia">julia&gt; Algebra.unset(Algebra.mkid(:a,3))</code></pre><h2 id=".13-The-Pochhammer-Notation-1"><a class="docs-heading-anchor" href="#.13-The-Pochhammer-Notation-1">7.13 The Pochhammer Notation</a><a class="docs-heading-anchor-permalink" href="#.13-The-Pochhammer-Notation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.pochhammer" href="#Reduce.Algebra.pochhammer"><code>Reduce.Algebra.pochhammer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pochhammer(a,k)</code></pre><p>The Pochhammer notation <span>$(a)_k$</span> (also called Pochhammer’s symbol) is supported by the binary operator <code>pochhammer(a,k)</code>. For a non-negative integer <code>k</code>, it is defined as (<a href="http://dlmf.nist.gov/5.2.iii">http://dlmf.nist.gov/5.2.iii</a>)</p><p><span>$(a)_0	= 1,$</span></p><p><span>$(a)_k	= a(a + 1)(a + 2)⋅⋅⋅(a + k - 1).$</span></p><p>For <span>$a ⁄= 0,±1,±2,…$</span>, this is equivalent to</p><p><span>$(a)k	= \frac{\Gamma (a+-k-)}{\Gamma (a)}$</span></p><p>With <code>rounded</code> off, this expression is evaluated numerically if <code>a</code> and <code>k</code> are both integral, and otherwise may be simplified where appropriate. The simplification rules are based upon algorithms supplied by Wolfram Koepf.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L406-L420">source</a></section></article><h2 id=".14-PF-Operator-1"><a class="docs-heading-anchor" href="#.14-PF-Operator-1">7.14 PF Operator</a><a class="docs-heading-anchor-permalink" href="#.14-PF-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.pf" href="#Reduce.Algebra.pf"><code>Reduce.Algebra.pf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pf(expr,var)</code></pre><p><code>R&quot;pf(⟨exp⟩,⟨var⟩)&quot;</code> transforms the expression <code>⟨exp⟩</code> into a list of partial fractions with respect to the main variable, <code>⟨var⟩</code>. <code>pf</code> does a complete partial fraction decomposition, and as the algorithms used are fairly unsophisticated (factorization and the extended Euclidean algorithm), the code may be unacceptably slow in complicated cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L422-L426">source</a></section></article><p><em>Example:</em> Given <code>R&quot;2/((x+1)^2*(x+2))&quot;</code> in the workspace, <code>R&quot;pf(ws,x)&quot;</code> gives the result</p><pre><code class="language-none">    2      - 2         2
{-------,-------,--------------}
  x + 2   x + 1    2
                  x  + 2*x + 1</code></pre><p>If you want the denominators in factored form, use <code>off(:exp)</code>. Thus, with <code>R&quot;2/((x+1)^2*(x+2))&quot;</code> in the workspace, the commands <code>R&quot;off(exp); pf(ws,x)&quot;</code> give the result</p><pre><code class="language-none">    2      - 2       2
{-------,-------,----------}
  x + 2   x + 1          2
                  (x + 1)</code></pre><p>To recombine the terms, <code>for each… sum</code> can be used. So with the above list in the workspace, <code>R&quot;for each j in ws sum j&quot;</code> returns the result</p><pre><code class="language-none">        2
------------------
                2
 (x + 2)*(x + 1)</code></pre><p>Alternatively, one can use the operations on lists to extract any desired term.</p><h2 id=".15-SELECT-Operator-1"><a class="docs-heading-anchor" href="#.15-SELECT-Operator-1">7.15 SELECT Operator</a><a class="docs-heading-anchor-permalink" href="#.15-SELECT-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.select" href="#Reduce.Algebra.select"><code>Reduce.Algebra.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">select(fnc,lst)</code></pre><p>The <code>select</code> operator extracts from a list, or from the arguments of an n–ary operator, elements corresponding to a boolean predicate. It is used with the syntax:</p><pre><code class="language-none">select(⟨FNC:function⟩,⟨LST:list⟩)</code></pre><p><code>FNC</code> can be one of the following forms:</p><ol><li>the name of an operator with a single argument: the operator is evaluated once on each element of <code>LST</code>;</li><li>an algebraic expression with exactly one free variable, i.e. a variable preceded by the tilde symbol. The expression is evaluated for each element of <code>⟨LST⟩</code>, with the element substituted for the free variable;</li><li>a replacement rule of the form <code>⟨var⟩ =&gt; ⟨rep⟩</code> where <code>⟨var⟩</code> is a variable (a kernel without subscript) and <code>⟨rep⟩</code> is an expression that contains <code>⟨var⟩</code>. <code>⟨rep⟩</code> is evaluated for each element of <code>LST</code> with the element substituted for <code>⟨var⟩</code>. <code>⟨var⟩</code> may be optionally preceded by a tilde.</li></ol><p>The rule form for <code>FNC</code> is needed when more than one free variable occurs.</p><p>The result of evaluating <code>FNC</code> is interpreted as a boolean value corresponding to the conventions of REDUCE. These values are composed with the leading operator of the input expression.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.select(:(~w&gt;0), (1,-1,2,-3,3))
(1, 2, 3)</code></pre><pre><code class="language-none">    select(evenp deg(~w,y),part((x+y)^5,0):=list)  
           -&gt; {X^5 ,10*X^3*Y^2 ,5*X*Y^4}  
    select(evenp deg(~w,x),2x^2+3x^3+4x^4) -&gt; 4X^4 + 2X^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L1141-L1168">source</a></section></article><h2 id=".16-SOLVE-Operator-1"><a class="docs-heading-anchor" href="#.16-SOLVE-Operator-1">7.16 SOLVE Operator</a><a class="docs-heading-anchor-permalink" href="#.16-SOLVE-Operator-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.solve" href="#Reduce.Algebra.solve"><code>Reduce.Algebra.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve(r...)</code></pre><p><code>solve</code> is an operator for solving one or more simultaneous algebraic equations. It is used with the syntax:</p><pre><code class="language-Julia">R&quot;SOLVE(⟨EXPRN:algebraic⟩[,⟨VAR:kernel⟩∣,⟨VARLIST:list of kernels⟩])&quot;</code></pre><p><code>exprn</code> is of the form <code>⟨expression⟩</code> or <code>{⟨expression1⟩,⟨expression2⟩, …}</code>. Each expression is an algebraic equation, or is the difference of the two sides of the equation. The second argument is either a kernel or a list of kernels representing the unknowns in the system. This argument may be omitted if the number of distinct, non-constant, top-level kernels equals the number of unknowns, in which case these kernels are presumed to be the unknowns.</p><p>For one equation, <code>solve</code> recursively uses factorization and decomposition, together with the known inverses of <code>log</code>, <code>sin</code>, <code>cos</code>, <code>^</code>, <code>acos</code>, <code>asin</code>, and linear, quadratic, cubic, quartic, or binomial factors. Solutions of equations built with exponentials or logarithms are often expressed in terms of Lambert’s <code>W</code> function. This function is (partially) implemented in the special functions package.</p><p>Linear equations are solved by the multi-step elimination method due to Bareiss, unless the switch <code>cramer</code> is on, in which case Cramer’s method is used. The Bareiss method is usually more efficient unless the system is large and dense.</p><p>Non-linear equations are solved using the Groebner basis package (chapter 16.28). Users should note that this can be quite a time consuming process.</p><p><em>Examples:</em></p><pre><code class="language-Julia">Algebra.solve(:(log(sin(x+3))^5 == 8),:x)
Algebra.solve(:(a*log(sin(x+3))^5 - b), :(sin(x+3)))
Algebra.solve((:(a*x+y==3),:(y=-2)),(:x,:y))</code></pre><p><code>solve</code> returns a list of solutions. If there is one unknown, each solution is an equation for the unknown. If a complete solution was found, the unknown will appear by itself on the left-hand side of the equation. On the other hand, if the solve package could not find a solution, the “solution” will be an equation for the unknown in terms of the operator <code>root_of</code>. If there are several unknowns, each solution will be a list of equations for the unknowns. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.solve(:(x^2==1),:x)
(:(x = 1), :(x = -1))

julia&gt; Algebra.solve(:(x^7-x^6+x^2==1),:x)
(:(x = root_of(x_ ^ 6 + x_ + 1, x_, tag_1)), :(x = 1))

julia&gt; Algebra.solve((:(x+3y==7),:(y-x==1)),(:x,:y))
(:(x = 1), :(y = 2))</code></pre><p>The <code>tag</code> argument is used to uniquely identify those particular solutions. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L428-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.root_multiplicities" href="#Reduce.Algebra.root_multiplicities"><code>Reduce.Algebra.root_multiplicities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">root_multiplicities()</code></pre><p>Solution multiplicities are stored in the global variable <code>root_multiplicities</code> rather than the solution list. The value of this variable is a list of the multiplicities of the solutions for the last call of <code>solve</code>. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.solve(:(x^2==2x-1),:x); Algebra.root_multiplicities()</code></pre><p>gives the results</p><pre><code class="language-Julia">(:(x = 1),)
 
(2,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/Reduce.jl#L181-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.multiplicities" href="#Reduce.multiplicities"><code>Reduce.multiplicities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiplicities(::Bool)</code></pre><p>If you want the multiplicities explicitly displayed, the switch <code>multiplicities</code> can be turned on. For example</p><pre><code class="language-Julia">julia&gt; Algebra.on(:multiplicities); Algebra.solve(:(x^2==2x-1),:x)</code></pre><p>yields the result</p><pre><code class="language-Julia">(:(x = 1), :(x = 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/switch.jl#L129-L140">source</a></section></article><h3 id=".16.1-Handling-of-Undetermined-Solutions-1"><a class="docs-heading-anchor" href="#.16.1-Handling-of-Undetermined-Solutions-1">7.16.1 Handling of Undetermined Solutions</a><a class="docs-heading-anchor-permalink" href="#.16.1-Handling-of-Undetermined-Solutions-1" title="Permalink"></a></h3><p>When <code>solve</code> cannot find a solution to an equation, it normally returns an equation for the relevant indeterminates in terms of the operator <code>root_of</code>. For example, the expression</p><pre><code class="language-Julia">julia&gt; Algebra.solve(:(cos(x)+log(x)),:x)</code></pre><p>returns the result</p><pre><code class="language-Julia">(:(x = root_of(cos(x_) + log(x_), x_, tag_1)),)</code></pre><p>An expression with a top-level <code>root_of</code> operator is implicitly a list with an unknown number of elements (since we don’t always know how many solutions an equation has). If a substitution is made into such an expression, closed form solutions can emerge. If this occurs, the <code>root_of</code> construct is replaced by an operator <code>one_of</code>. At this point it is of course possible to transform the result of the original <code>solve</code> operator expression into a standard <code>solve</code> solution. To effect this, the operator <code>expand_cases</code> can be used.</p><p>The following example shows the use of these facilities:</p><pre><code class="language-Julia">julia&gt; Algebra.solve(:(-a*x^3+a*x^2+x^4-x^3-4*x^2+4),:x)
(:(x = root_of((a * x_ ^ 2 - x_ ^ 3) + 4x_ + 4, x_, tag_2)), :(x = 1))

julia&gt; Algebra.sub(:a=-1,ans)
(:(x=one_of((2, -1, -2), tag_2)), :(x=1))
 
julia&gt; Algebra.expand_cases(ans)
(:(x=2), :(x=-1), :(x=-2), :(x=1))</code></pre><h3 id=".16.2-Solutions-of-Equations-Involving-Cubics-and-Quartics-1"><a class="docs-heading-anchor" href="#.16.2-Solutions-of-Equations-Involving-Cubics-and-Quartics-1">7.16.2 Solutions of Equations Involving Cubics and Quartics</a><a class="docs-heading-anchor-permalink" href="#.16.2-Solutions-of-Equations-Involving-Cubics-and-Quartics-1" title="Permalink"></a></h3><p>Since roots of cubics and quartics can often be very messy, a switch <code>fullroots</code> is available, that, when off (the default), will prevent the production of a result in closed form. The <code>root_of</code> construct will be used in this case instead.</p><p>In constructing the solutions of cubics and quartics, trigonometrical forms are used where appropriate. This option is under the control of a switch <code>trigform</code>, which is normally on.</p><p>The following example illustrates the use of these facilities:</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:xx =&gt; :(solve(x^3+x+1,x)))
 
julia&gt; rcall(:xx)
(:(x = root_of(x_ ^ 3 + x_ + 1, x_, tag_1)),)

julia&gt; Algebra.on(:fullroots)

julia&gt; collect(rcall(:xx))
3-element Array{Expr,1}:
 :(x = -((sqrt(3) * cosh(asinh((3 * sqrt(3)) // 2) // 3) * im - sinh(asinh((3 * sqrt(3)) // 2) // 3))) // sqrt(3))
 :(x = (sqrt(3) * cosh(asinh((3 * sqrt(3)) // 2) // 3) * im + sinh(asinh((3 * sqrt(3)) // 2) // 3)) // sqrt(3))
 :(x = (-2 * sinh(asinh((3 * sqrt(3)) // 2) // 3)) // sqrt(3))

julia&gt; Algebra.off(:trigform)
 
julia&gt; collect(rcall(:xx))
3-element Array{Expr,1}:
 :(x = -(((sqrt(31) - 3 * sqrt(3)) ^ (2 / 3) * (sqrt(3) * im + 1) + 2 ^ (2 / 3) * (sqrt(3) * im - 1))) / (2 * (sqrt(31) - 3 * sqrt(3)) ^ (1 / 3) * 6 ^ (1 / 3) * 3 ^ (1 / 6)))
 :(x = (2 ^ (2 / 3) * (sqrt(3) * im + 1) + (sqrt(31) - 3 * sqrt(3)) ^ (2 / 3) * (sqrt(3) * im - 1)) / (2 * (sqrt(31) - 3 * sqrt(3)) ^ (1 / 3) * 6 ^ (1 / 3) * 3 ^ (1 / 6)))   
 :(x = ((sqrt(31) - 3 * sqrt(3)) ^ (2 / 3) - 2 ^ (2 / 3)) / ((sqrt(31) - 3 * sqrt(3)) ^ (1 / 3) * 6 ^ (1 / 3) * 3 ^ (1 / 6))) </code></pre><h3 id=".16.3-Other-Options-1"><a class="docs-heading-anchor" href="#.16.3-Other-Options-1">7.16.3 Other Options</a><a class="docs-heading-anchor-permalink" href="#.16.3-Other-Options-1" title="Permalink"></a></h3><p>If <code>solvesingular</code> is on (the default setting), degenerate systems such as <code>x+y=0</code>, <code>2x+2y=0</code> will be solved by introducing appropriate arbitrary constants. The consistent singular equation <code>0=0</code> or equations involving functions with multiple inverses may introduce unique new indeterminant kernels <code>arbcomplex(j)</code>, or <code>arbint(j)</code>, (<span>$j=1,2,...$</span>), representing arbitrary complex or integer numbers respectively. To automatically select the principal branches, do <code>off(:allbranch)</code>. To avoid the introduction of new indeterminant kernels do <code>off(:arbvars)</code> – then no equations are generated for the free variables and their original names are used to express the solution forms. To suppress solutions of consistent singular equations do <code>off(:solvesingular)</code>.</p><p>To incorporate additional inverse functions do, for example:</p><pre><code class="language-Julia">R&quot;put(’sinh,’inverse,’asinh)&quot;
R&quot;put(’asinh,’inverse,’sinh)&quot;</code></pre><p>together with any desired simplification rules such as</p><pre><code class="language-none">R&quot;for all x let sinh(asinh(x))=x, asinh(sinh(x))=x&quot;</code></pre><p>For completeness, functions with non-unique inverses should be treated as <code>^</code>, <code>sin</code>, and <code>cos</code> are in the <code>solve</code> module source.</p><p>Arguments of <code>asin</code> and <code>acos</code> are not checked to ensure that the absolute value of the real part does not exceed 1; and arguments of <code>log</code> are not checked to ensure that the absolute value of the imaginary part does not exceed <code>π</code>; but checks (perhaps involving user response for non-numerical arguments) could be introduced using <code>let</code> statements for these operators.</p><h3 id=".16.4-Parameters-and-Variable-Dependency-1"><a class="docs-heading-anchor" href="#.16.4-Parameters-and-Variable-Dependency-1">7.16.4 Parameters and Variable Dependency</a><a class="docs-heading-anchor-permalink" href="#.16.4-Parameters-and-Variable-Dependency-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.requirements" href="#Reduce.Algebra.requirements"><code>Reduce.Algebra.requirements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">requirements()</code></pre><p>The proper design of a variable sequence supplied as a second argument to <code>solve</code> is important for the structure of the solution of an equation system. Any unknown in the system not in this list is considered totally free. E.g. the call</p><pre><code class="language-Julia">Algebra.solve((:(x==2z),:(z==2y)),(:z,))</code></pre><p>produces an empty list as a result because there is no function <code>z = z(x,y)</code> which fulfills both equations for arbitrary <code>x</code> and <code>y</code> values. In such a case the share variable <code>requirements</code> displays a set of restrictions for the parameters of the system:</p><pre><code class="language-Julia">julia&gt; Algebra.requirements()
(:(x - 4y),)</code></pre><p>The non-existence of a formal solution is caused by a contradiction which disappears only if the parameters of the initial system are set such that all members of the requirements list take the value zero. For a linear system the set is complete: a solution of the requirements list makes the initial system solvable. E.g. in the above case a substitution <span>$x = 4y$</span> makes the equation set consistent. For a non-linear system only one inconsistency is detected. If such a system has more than one inconsistency, you must reduce them one after the other. 1 The set shows you also the dependency among the parameters: here one of <span>$x$</span> and <span>$y$</span> is free and a formal solution of the system can be computed by adding it to the variable list of <code>solve</code>. The requirement set is not unique – there may be other such sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/Reduce.jl#L196-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.assumptions" href="#Reduce.Algebra.assumptions"><code>Reduce.Algebra.assumptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assumptions()</code></pre><p>A system with parameters may have a formal solution, e.g. </p><pre><code class="language-Julia">julia&gt; Algebra.solve((:(x==a*z+1),:(0==b*z-y)),(:z,:x))
(:(z = y // b), :(x = (a * y + b) // b))</code></pre><p>which is not valid for all possible values of the parameters. The variable <code>assumptions</code> contains then a list of restrictions: the solutions are valid only as long as none of these expressions vanishes. Any zero of one of them represents a special case that is not covered by the formal solution. In the above case the value is</p><pre><code class="language-Julia">julia&gt; Algebra.assumptions()
(:b,)</code></pre><p>which excludes formally the case <span>$b = 0$</span>; obviously this special parameter value makes the system singular. The set of assumptions is complete for both, linear and non–linear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/Reduce.jl#L213-L227">source</a></section></article><p><code>solve</code> rearranges the variable sequence to reduce the (expected) computing time. This behavior is controlled by the switch <code>varopt</code>, which is on by default. If it is turned off, the supplied variable sequence is used or the system kernel ordering is taken if the variable list is omitted. The effect is demonstrated by an example:</p><pre><code class="language-Julia">julia&gt; @rcall s=(y^3+3x=0,x^2+y^2=1);
 
julia&gt; Algebra.solve(:s,(:y,:x)) |&gt; collect
2-element Array{Expr,1}:
 :(y = root_of((y_ ^ 6 + 9 * y_ ^ 2) - 9, y_, tag_2))
 :(x = -(y ^ 3) // 3)    

julia&gt; Algebra.off(:varopt); Algebra.solve(:s,(:y,:x)) |&gt; collect
2-element Array{Expr,1}:
 :(y = (-(((x ^ 4 - 2 * x ^ 2) + 10)) * x) // 3)                     
 :(x = root_of(((x_ ^ 6 - 3 * x_ ^ 4) + 12 * x_ ^ 2) - 1, x_, tag_3))</code></pre><p>In the first case, <code>solve</code> forms the solution as a set of pairs <span>$(y_i,x(y_i))$</span> because the degree of x is higher – such a rearrangement makes the internal computation of the Gröbner basis generally faster. For the second case the explicitly given variable sequence is used such that the solution has now the form <code>(x_i,y(x_i))</code>. Controlling the variable sequence is especially important if the system has one or more free variables. As an alternative to turning off <code>varopt</code>, a partial dependency among the variables can be declared using the <code>depend</code> statement: <code>solve</code> then rearranges the variable sequence but keeps any variable ahead of those on which it depends.</p><pre><code class="language-Julia">julia&gt; Algebra.on(:varopt)

julia&gt; @rcall s=(a^3+b,b^2+c);

julia&gt; Algebra.solve(:s,(:a,:b,:c))
(:(a = arbcomplex(1)), :(b = -(a ^ 3)), :(c = -(a ^ 6))) 

julia&gt; Algebra.depend(:a,:c); Algebra.depend(:b,:c)

julia&gt; Algebra.solve(:s,(:a,:b,:c))
3-element Array{Expr,1}:
 :(c = arbcomplex(2))                  
 :(a = root_of(a_ ^ 6 + c, a_, tag_3))
 :(b = -(a ^ 3)) </code></pre><p>Here <code>solve</code> is forced to put <span>$c$</span> after <span>$a$</span> and after <span>$b$</span>, but there is no obstacle to interchanging <span>$a$</span> and <span>$b$</span>.</p><h2 id=".17-Even-and-Odd-Operators-1"><a class="docs-heading-anchor" href="#.17-Even-and-Odd-Operators-1">7.17 Even and Odd Operators</a><a class="docs-heading-anchor-permalink" href="#.17-Even-and-Odd-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.even" href="#Reduce.Algebra.even"><code>Reduce.Algebra.even</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">even(r...)</code></pre><p>An operator can be declared to be even in its first argument by the declarations <code>even</code>. Expressions involving an operator declared in this manner are transformed if the first argument contains a minus sign. Any other arguments are not affected. For example, the declaration</p><pre><code class="language-Julia">julia&gt; Algebra.even(:f1)</code></pre><p>means that</p><pre><code class="language-none">        f1(-a)    -&gt;    f1(a)  
        f1(-a,-b) -&gt;    f1(a,-b)  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L464-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.odd" href="#Reduce.Algebra.odd"><code>Reduce.Algebra.odd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">odd(r...)</code></pre><p>An operator can be declared to be odd in its first argument by the declarations <code>odd</code>. Expressions involving an operator declared in this manner are transformed if the first argument contains a minus sign. Any other arguments are not affected. In addition, if say <code>f</code> is declared odd, then <code>f(0)</code> is replaced by zero unless <code>f</code> is also declared non zero by the declaration <code>nonzero</code>. For example, the declarations</p><pre><code class="language-Julia">julia&gt; Algebra.odd(:f2)</code></pre><p>means that</p><pre><code class="language-none">        f2(-a)    -&gt;   -f2(a)  
        f2(0)     -&gt;    0</code></pre><p>To inhibit the last transformation, say <code>nonzero(:f2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L478-L491">source</a></section></article><h2 id=".18-Linear-Operators-1"><a class="docs-heading-anchor" href="#.18-Linear-Operators-1">7.18 Linear Operators</a><a class="docs-heading-anchor-permalink" href="#.18-Linear-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.linear" href="#Reduce.Algebra.linear"><code>Reduce.Algebra.linear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linear(r...)</code></pre><p>An operator can be declared to be linear in its first argument over powers of its second argument. If an operator <code>f</code> is so declared, <code>f</code> of any sum is broken up into sums of <code>f</code>s, and any factors that are not powers of the variable are taken outside. This means that <code>f</code> must have (at least) two arguments. In addition, the second argument must be an identifier (or more generally a kernel), not an expression.</p><p><em>Example:</em> If <code>f</code> were declared linear, then</p><pre><code class="language-none">f(a*x^5+b*x+c,x) -&gt;  f(x^5,x)*a + f(x,x)*b + f(1,x)*c</code></pre><p>More precisely, not only will the variable and its powers remain within the scope of the <code>f</code> operator, but so will any variable and its powers that had been declared to <code>depend</code> on the prescribed variable; and so would any expression that contains that variable or a dependent variable on any level, e.g. <code>cos(sin(x))</code>.</p><p>To declare operators <code>f</code> and <code>g</code> to be linear operators, use:</p><pre><code class="language-Julia">julia&gt; Algebra.linear(:f,:g)</code></pre><p>The analysis is done of the first argument with respect to the second; any other arguments are ignored. It uses the following rules of evaluation:</p><pre><code class="language-none">f(0) 		-&gt; 0
f(-y,x) 	-&gt; -f(y,x)
f(y+z,x) 	-&gt; f(y,x)+f(z,x)
f(y*z,x) 	-&gt; z*f(y,x)   	if z does not depend on x
f(y/z,x) 	-&gt; f(y,x)/z	if z does not depend on x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L493-L516">source</a></section></article><p>To summarize, <code>y</code> “depends” on the indeterminate <code>x</code> in the above if either of the following hold:</p><ol><li><code>y</code> is an expression that contains <code>x</code> at any level as a variable, e.g.: <code>cos(sin(x))</code></li><li>Any variable in the expression <code>y</code> has been declared dependent on <code>x</code> by use of the declaration <code>depend</code>.</li></ol><p>The use of such linear operators can be seen in the paper Fox, J.A. and A. C. Hearn, “Analytic Computation of Some Integrals in Fourth Order Quantum Electrodynamics” Journ. Comp. Phys. 14 (1974) 301-317, which contains a complete listing of a program for definite integration of some expressions that arise in fourth order quantum electrodynamics.</p><h2 id=".19-Non-Commuting-Operators-1"><a class="docs-heading-anchor" href="#.19-Non-Commuting-Operators-1">7.19 Non-Commuting Operators</a><a class="docs-heading-anchor-permalink" href="#.19-Non-Commuting-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.noncom" href="#Reduce.Algebra.noncom"><code>Reduce.Algebra.noncom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">noncom(r...)</code></pre><p>An operator can be declared to be non-commutative under multiplication by the declaration <code>noncom</code>.</p><p><em>Example:</em> After the declaration</p><pre><code class="language-Julia">julia&gt; Algebra.noncom(:u,:v);</code></pre><p>the expressions <code>u(x)*u(y)-u(y)*u(x)</code> and <code>u(x)*v(y)-v(y)*u(x)</code> will remain unchanged on simplification, and in particular will not simplify to zero.</p><p>Note that it is the operator (<code>u</code> and <code>v</code> in the above example) and not the variable that has the non-commutative property.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L518-L530">source</a></section></article><p>The <code>let</code> statement may be used to introduce rules of evaluation for such operators. In particular, the boolean operator <code>ordp</code> is useful for introducing an ordering on such expressions.</p><p><em>Example:</em> The rule</p><pre><code class="language-Julia">R&quot;for all x,y such that x neq y and ordp(x,y) let u(x)*u(y)= u(y)*u(x)+comm(x,y)&quot;</code></pre><p>would introduce the commutator of <code>u(x)</code> and <code>u(y)</code> for all <code>x</code> and <code>y</code>. Note that since <code>ordp(x,x)</code> is true, the equality check is necessary in the degenerate case to avoid a circular loop in the rule.</p><h2 id=".20-Symmetric-and-Antisymmetric-Operators-1"><a class="docs-heading-anchor" href="#.20-Symmetric-and-Antisymmetric-Operators-1">7.20 Symmetric and Antisymmetric Operators</a><a class="docs-heading-anchor-permalink" href="#.20-Symmetric-and-Antisymmetric-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.symmetric" href="#Reduce.Algebra.symmetric"><code>Reduce.Algebra.symmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symmetric(r...)</code></pre><p>An operator can be declared to be symmetric with respect to its arguments by the declaration <code>symmetric</code>. For example</p><pre><code class="language-Julia">julia&gt; Algebra.symmetric(:u,:v);</code></pre><p>means that any expression involving the top level operators <code>u</code> or <code>v</code> will have its arguments reordered to conform to the internal order used by REDUCE. The user can change this order for kernels by the command <code>korder</code>. For example, <code>u(x,v(1,2))</code> would become <code>u(v(2,1),x)</code>, since numbers are ordered in decreasing order, and expressions are ordered in decreasing order of complexity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L533-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.antisymmetric" href="#Reduce.Algebra.antisymmetric"><code>Reduce.Algebra.antisymmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">antisymmetric(r...)</code></pre><p>the declaration <code>antisymmetric</code> declares an operator antisymmetric. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.antisymmetric(:l,:m);</code></pre><p>means that any expression involving the top level operators <code>l</code> or <code>m</code> will have its arguments reordered to conform to the internal order of the system, and the sign of the expression changed if there are an odd number of argument interchanges necessary to bring about the new order.</p><p>For example, <code>l(x,m(1,2))</code> would become <code>-l(-m(2,1),x)</code> since one interchange occurs with each operator. An expression like <code>l(x,x)</code> would also be replaced by <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L544-L554">source</a></section></article><h2 id=".21-Declaring-New-Prefix-Operators-1"><a class="docs-heading-anchor" href="#.21-Declaring-New-Prefix-Operators-1">7.21 Declaring New Prefix Operators</a><a class="docs-heading-anchor-permalink" href="#.21-Declaring-New-Prefix-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.operator" href="#Reduce.Algebra.operator"><code>Reduce.Algebra.operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operator(r...)</code></pre><p>The user may add new prefix operators to the system by using the declaration <code>operator</code>. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.operator(:h,:g1,:arctan)</code></pre><p>adds the prefix operators <code>h</code>, <code>g1</code> and <code>arctan</code> to the system.</p><p>This allows symbols like <code>h(w)</code>, <code>h(x,y,z)</code>, <code>g1(p+q)</code>, <code>arctan(u/v)</code> to be used in expressions, but no meaning or properties of the operator are implied. The same operator symbol can be used equally well as a 0-, 1-, 2-, 3-, etc.-place operator.</p><p>To give a meaning to an operator symbol, or express some of its properties, <code>let</code> statements can be used, or the operator can be given a definition as a procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L556-L568">source</a></section></article><p>If the user forgets to declare an identifier as an operator, the system will prompt the user to do so in interactive mode, or do it automatically in non-interactive mode. A diagnostic message will also be printed if an identifier is declared <code>operator</code> more than once.</p><p>Operators once declared are global in scope, and so can then be referenced anywhere in the program. In other words, a declaration within a block (or a procedure) does not limit the scope of the operator to that block, nor does the operator go away on exiting the block (use <code>clear</code> instead for this purpose).</p><h2 id=".22-Declaring-New-Infix-Operators-1"><a class="docs-heading-anchor" href="#.22-Declaring-New-Infix-Operators-1">7.22 Declaring New Infix Operators</a><a class="docs-heading-anchor-permalink" href="#.22-Declaring-New-Infix-Operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.infix" href="#Reduce.Algebra.infix"><code>Reduce.Algebra.infix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">infix(r...)</code></pre><p>Users can add new infix operators by using the declarations <code>infix</code> and <code>precedence</code>. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.infix(:mm)</code></pre><p>The declaration <code>infix(:mm)</code> would allow one to use the symbol <code>mm</code> as an infix operator: <code>R&quot;a mm b&quot;</code> instead of <code>R&quot;mm(a,b)&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L650-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.precedence" href="#Reduce.Algebra.precedence"><code>Reduce.Algebra.precedence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precedence(a,b)</code></pre><p>Users can add new infix operators by using the declarations <code>infix</code> and <code>precedence</code>. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.precedence(:mm,:-)</code></pre><p>The declaration <code>precedence(:mm,:-)</code> says that <code>mm</code> should be inserted into the infix operator precedence list just after the <code>-</code> operator. This gives it higher precedence than <code>-</code> and lower precedence than <code>*</code> . Thus <code>R&quot;a - b mm c - d&quot;</code> means <code>R&quot;a - (b mm c) - d&quot;</code>, while <code>R&quot;a * b mm c * d&quot;</code> means <code>R&quot;(a * b) mm (c * d)&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L661-L669">source</a></section></article><p>Both infix and prefix operators have no transformation properties unless <code>let</code> statements or procedure declarations are used to assign a meaning.</p><p>We should note here that infix operators so defined are always binary: <code>R&quot;a mm b mm c&quot;</code> means <code>R&quot;(a mm b) mm c&quot;</code>.</p><h2 id=".23-Creating/Removing-Variable-Dependency-1"><a class="docs-heading-anchor" href="#.23-Creating/Removing-Variable-Dependency-1">7.23 Creating/Removing Variable Dependency</a><a class="docs-heading-anchor-permalink" href="#.23-Creating/Removing-Variable-Dependency-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.depend" href="#Reduce.Algebra.depend"><code>Reduce.Algebra.depend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depend(r...)</code></pre><p>There are several facilities in REDUCE, such as the differentiation operator and the linear operator facility, that can utilize knowledge of the dependency between various variables, or kernels. Such dependency may be expressed by the command <code>depend</code>. This takes an arbitrary number of arguments and sets up a dependency of the first argument on the remaining arguments. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.depend(:x,:y,:z)</code></pre><p>says that <code>x</code> is dependent on both <code>y</code> and <code>z</code>.</p><pre><code class="language-Julia">julia&gt; Algebra.depend(:z,:(cos(x)),:y)</code></pre><p>says that <code>z</code> is dependent on <code>cos(x)</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L570-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Reduce.Algebra.nodepend" href="#Reduce.Algebra.nodepend"><code>Reduce.Algebra.nodepend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodepend(r...)</code></pre><p>Dependencies introduced by <code>depend</code> can be removed by <code>nodepend</code>. The arguments of this are the same as for <code>depend</code>. For example, given the above dependencies,</p><pre><code class="language-Julia">julia&gt; Algebra.nodepend(:z,:(cos(x)))</code></pre><p>says that <code>z</code> is no longer dependent on <code>cos(x)</code>, although it remains dependent on <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/0865869a8259337bb69c81aad012a561f14fb5a7/src/args.jl#L584-L592">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../06-commands-declarations/">« 6 Commands and Declarations</a><a class="docs-footer-nextpage" href="../08-display/">8 Display and Structuring of Expressions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 15 February 2020 18:26">Saturday 15 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
