<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3 Expressions · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../library.html">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="acknowledgement.html">Acknowledgement</a></li><li><a class="toctext" href="01-introduction.html">1 Introductory Information</a></li><li><a class="toctext" href="02-structure.html">2 Structure of Programs</a></li><li class="current"><a class="toctext" href="03-expressions.html">3 Expressions</a><ul class="internal"><li><a class="toctext" href="#.1-Scalar-Expressions-1">3.1 Scalar Expressions</a></li><li><a class="toctext" href="#.2-Integer-Expressions-1">3.2 Integer Expressions</a></li><li><a class="toctext" href="#.3-Boolean-Expressions-1">3.3 Boolean Expressions</a></li><li><a class="toctext" href="#.4-Equations-1">3.4 Equations</a></li><li><a class="toctext" href="#.5-Proper-Statements-as-Expressions-1">3.5 Proper Statements as Expressions</a></li></ul></li><li><a class="toctext" href="04-lists.html">4 Lists</a></li><li><a class="toctext" href="05-statements.html">5 Statements</a></li><li><a class="toctext" href="06-commands-declarations.html">6 Commands and Declarations</a></li><li><a class="toctext" href="07-prefix-ops.html">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="08-display.html">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="09-polynomials.html">9 Polynomials and Rationals</a></li><li><a class="toctext" href="10-properties.html">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="11-substitution.html">11 Substitution Commands</a></li><li><a class="toctext" href="12-file-io.html">12 File Handling Commands</a></li><li><a class="toctext" href="13-interactive.html">13 Commands for Interactive Use</a></li><li><a class="toctext" href="14-matrix.html">14 Matrix Calculations</a></li><li><a class="toctext" href="15-procedures.html">15 Procedures</a></li><li><a class="toctext" href="16-packages.html">16 User Contributed Packages</a></li><li><a class="toctext" href="17-symbolic.html">17 Symbolic Mode</a></li><li><a class="toctext" href="18-physics.html">18 Calculations in High Energy Physics</a></li><li><a class="toctext" href="19-rlisp.html">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="20-maintaining.html">20 Maintaining REDUCE</a></li><li><a class="toctext" href="A-reserved.html">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="B-bibliography.html">Appendix B: Bibliography</a></li><li><a class="toctext" href="C-changelog.html">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="index.html">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href="03-expressions.html">3 Expressions</a></li></ul><a class="edit-page" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/03-expressions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>3 Expressions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Expressions-1" href="#Expressions-1">3 Expressions</a></h1><p>REDUCE expressions may be of several types and consist of sequences of numbers, variables, operators, left and right parentheses and commas. The most common types are as follows:</p><ul><li><a href="03-expressions.html#Expressions-1">3 Expressions</a></li><ul><li><a href="03-expressions.html#.1-Scalar-Expressions-1">3.1 Scalar Expressions</a></li><li><a href="03-expressions.html#.2-Integer-Expressions-1">3.2 Integer Expressions</a></li><li><a href="03-expressions.html#.3-Boolean-Expressions-1">3.3 Boolean Expressions</a></li><li><a href="03-expressions.html#.4-Equations-1">3.4 Equations</a></li><li><a href="03-expressions.html#.5-Proper-Statements-as-Expressions-1">3.5 Proper Statements as Expressions</a></li></ul></ul><p>Reduce expressions encapsulated into <code>RExpr</code> objects can be manipulated within julia using the standard syntax. Create an expression object either using the <code>RExpr(&quot;expression&quot;)</code> string constructor or <code>R&quot;expression&quot;</code>. Additionally, arbitrary julia expressions can also be parsed directly using the <code>RExpr(expr)</code> constructor. Internally <code>RExpr</code> objects are represented as an array that can be accessed by calling <code>*.str[n]</code> on the object. Julia abstract syntax trees are automatically converted into sequences of reduce statements (using <code>RExpr</code> constructor).</p><h2><a class="nav-anchor" id=".1-Scalar-Expressions-1" href="#.1-Scalar-Expressions-1">3.1 Scalar Expressions</a></h2><p>Using the arithmetic operations <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code> (power) and parentheses, scalar expressions are composed from numbers, ordinary “scalar” variables (identifiers), array names with subscripts, operator or procedure names with arguments and statement expressions.</p><p><em>Examples:</em></p><pre><code class="language-Julia">RExpr(&quot;x&quot;)
R&quot;x^3 - 2*y/(2*z^2 - df(x,z))&quot;
R&quot;(p^2 + m^2)^(1/2)*log (y/m)&quot;
R&quot;a(5) + b(i,q)&quot;</code></pre><p>The symbol <code>**</code> may be used as an alternative to the caret symbol (<code>^</code>) for forming powers, particularly in those systems that do not support a caret symbol.</p><p>Statement expressions, usually in parentheses, can also form part of a scalar expression, as in the example</p><pre><code class="language-Julia">R&quot;w + (c:=x+y) + z&quot;</code></pre><p>When the algebraic value of an expression is needed, REDUCE determines it, starting with the algebraic values of the parts, roughly as follows:</p><p>Variables and operator symbols with an argument list have the algebraic values they were last assigned, or if never assigned stand for themselves. However, array elements have the algebraic values they were last assigned, or, if never assigned, are taken to be 0.</p><p>Procedures are evaluated with the values of their actual parameters.</p><p>In evaluating expressions, the standard rules of algebra are applied. Unfortunately, this algebraic evaluation of an expression is not as unambiguous as is numerical evaluation. This process is generally referred to as “simplification” in the sense that the evaluation usually but not always produces a simplified form for the expression.</p><p>There are many options available to the user for carrying out such simplification. If the user doesn’t specify any method, the default method is used. The default evaluation of an expression involves expansion of the expression and collection of like terms, ordering of the terms, evaluation of derivatives and other functions and substitution for any expressions which have values assigned or declared (see assignments and <code>let</code> statements). In many cases, this is all that the user needs.</p><p>The declarations by which the user can exercise some control over the way in which the evaluation is performed are explained in other sections. For example, if a real (floating point) number is encountered during evaluation, the system will normally convert it into a ratio of two integers. If the user wants to use real arithmetic, he can effect this by the command <code>rounded(true)</code>. Other modes for coefficient arithmetic are described elsewhere.</p><p>If an illegal action occurs during evaluation (such as division by zero) or functions are called with the wrong number of arguments, and so on, an appropriate error message is generated.</p><h2><a class="nav-anchor" id=".2-Integer-Expressions-1" href="#.2-Integer-Expressions-1">3.2 Integer Expressions</a></h2><p>These are expressions which, because of the values of the constants and variables in them, evaluate to whole numbers.</p><p><em>Examples:</em></p><pre><code class="language-Julia">R&quot;2&quot;;      R&quot;37 * 999&quot;;       R&quot;(x + 3)^2 - x^2 - 6*x&quot;</code></pre><p>are obviously integer expressions.</p><pre><code class="language-Julia">R&quot;j + k - 2 * j^2&quot;</code></pre><p>is an integer expression when <code>J</code> and <code>K</code> have values that are integers, or if not integers are such that “the variables and fractions cancel out”, as in</p><pre><code class="language-Julia">R&quot;k - 7/3 - j + 2/3 + 2*j^2&quot;</code></pre><h2><a class="nav-anchor" id=".3-Boolean-Expressions-1" href="#.3-Boolean-Expressions-1">3.3 Boolean Expressions</a></h2><p>Not initially supported by Reduce.jl parser, see <a href="http://www.reduce-algebra.com/manual/manualse10.html">upstream docs</a> for more information.</p><h2><a class="nav-anchor" id=".4-Equations-1" href="#.4-Equations-1">3.4 Equations</a></h2><p>Equations are a particular type of expression with the syntax</p><pre><code class="language-none">R&quot;⟨expression⟩=⟨expression⟩&quot;</code></pre><p>In addition to their role as boolean expressions, they can also be used as arguments to several operators (e.g., <code>solve</code>), and can be returned as values.</p><p>Under normal circumstances, the right-hand-side of the equation is evaluated but not the left-hand-side. This also applies to any substitutions made by the <code>sub</code> operator. If both sides are to be evaluated, the switch <code>evallhseqp</code> should be turned on.</p><p>To facilitate the handling of equations, two selectors, <code>lhs</code> and <code>rhs</code>, which return the left- and right-hand sides of an equation respectively, are provided.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.lhs" href="#Reduce.Algebra.lhs"><code>Reduce.Algebra.lhs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lhs(::Union{Expr,RExpr})</code></pre><p>Returns the left-hand side of an equation.</p><p><strong>Examples</strong></p><pre><code class="language-Julia">julia&gt; Algebra.lhs(R&quot;a+b=c&quot;)

a + b
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/d6ec549d281933c36ecb84d50203ffd785808bc3/src/unary.jl#L313-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.rhs" href="#Reduce.Algebra.rhs"><code>Reduce.Algebra.rhs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rhs(::Union{Expr,RExpr})</code></pre><p>Returns the right-hand side of an equation.</p><p><strong>Examples</strong></p><pre><code class="language-Julia">julia&gt; Algebra.rhs(R&quot;a+b=c&quot;)

c
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/d6ec549d281933c36ecb84d50203ffd785808bc3/src/unary.jl#L327-L339">source</a></section><h2><a class="nav-anchor" id=".5-Proper-Statements-as-Expressions-1" href="#.5-Proper-Statements-as-Expressions-1">3.5 Proper Statements as Expressions</a></h2><p>Several kinds of proper statements deliver an algebraic or numerical result of some kind, which can in turn be used as an expression or part of an expression. For example, an assignment statement itself has a value, namely the value assigned. So</p><pre><code class="language-Julia">R&quot;2 * (x := a+b)&quot;</code></pre><p>is equal to <code>R&quot;2*(a+b)&quot;</code>, as well as having the “side-effect” of assigning the value <code>a+b</code> to <code>X</code>. In context,</p><pre><code class="language-Julia">R&quot;y := 2 * (x := a+b);&quot;</code></pre><p>sets <code>X</code> to <code>a+b</code> and <code>Y</code> to <code>2*(a+b)</code>.</p><p><strong>Note that if the Reduce.jl parser is used to convert these types of expressions to Julia AST, issues can occur since an equivalent feature does not exist in the Julia language.</strong></p><p>The sections on the various proper statement types indicate which of these statements are also useful as expressions.</p><footer><hr/><a class="previous" href="02-structure.html"><span class="direction">Previous</span><span class="title">2 Structure of Programs</span></a><a class="next" href="04-lists.html"><span class="direction">Next</span><span class="title">4 Lists</span></a></footer></article></body></html>
