<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>18 Calculations in High Energy Physics · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../library.html">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="acknowledgement.html">Acknowledgement</a></li><li><a class="toctext" href="01-introduction.html">1 Introductory Information</a></li><li><a class="toctext" href="02-structure.html">2 Structure of Programs</a></li><li><a class="toctext" href="03-expressions.html">3 Expressions</a></li><li><a class="toctext" href="04-lists.html">4 Lists</a></li><li><a class="toctext" href="05-statements.html">5 Statements</a></li><li><a class="toctext" href="06-commands-declarations.html">6 Commands and Declarations</a></li><li><a class="toctext" href="07-prefix-ops.html">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="08-display.html">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="09-polynomials.html">9 Polynomials and Rationals</a></li><li><a class="toctext" href="10-properties.html">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="11-substitution.html">11 Substitution Commands</a></li><li><a class="toctext" href="12-file-io.html">12 File Handling Commands</a></li><li><a class="toctext" href="13-interactive.html">13 Commands for Interactive Use</a></li><li><a class="toctext" href="14-matrix.html">14 Matrix Calculations</a></li><li><a class="toctext" href="15-procedures.html">15 Procedures</a></li><li><a class="toctext" href="16-packages.html">16 User Contributed Packages</a></li><li><a class="toctext" href="17-symbolic.html">17 Symbolic Mode</a></li><li class="current"><a class="toctext" href="18-physics.html">18 Calculations in High Energy Physics</a><ul class="internal"><li><a class="toctext" href="#.1-High-Energy-Physics-Operators-1">18.1 High Energy Physics Operators</a></li><li><a class="toctext" href="#.2-Vector-Variables-1">18.2 Vector Variables</a></li><li><a class="toctext" href="#.3-Additional-Expression-Types-1">18.3 Additional Expression Types</a></li><li><a class="toctext" href="#.4-Trace-Calculations-1">18.4 Trace Calculations</a></li><li><a class="toctext" href="#.5-Mass-Declarations-1">18.5 Mass Declarations</a></li><li><a class="toctext" href="#.6-Example-1">18.6 Example</a></li><li><a class="toctext" href="#.7-Extensions-to-More-Than-Four-Dimensions-1">18.7 Extensions to More Than Four Dimensions</a></li></ul></li><li><a class="toctext" href="19-rlisp.html">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="20-maintaining.html">20 Maintaining REDUCE</a></li><li><a class="toctext" href="A-reserved.html">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="B-bibliography.html">Appendix B: Bibliography</a></li><li><a class="toctext" href="C-changelog.html">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="index.html">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href="18-physics.html">18 Calculations in High Energy Physics</a></li></ul><a class="edit-page" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/18-physics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>18 Calculations in High Energy Physics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Calculations-in-High-Energy-Physics-1" href="#Calculations-in-High-Energy-Physics-1">18 Calculations in High Energy Physics</a></h1><p>A set of REDUCE commands is provided for users interested in symbolic calculations in high energy physics. Several extensions to our basic syntax are necessary, however, to allow for the different data structures encountered.</p><ul><li><a href="18-physics.html#Calculations-in-High-Energy-Physics-1">18 Calculations in High Energy Physics</a></li><ul><li><a href="18-physics.html#.1-High-Energy-Physics-Operators-1">18.1 High Energy Physics Operators</a></li><li><a href="18-physics.html#.2-Vector-Variables-1">18.2 Vector Variables</a></li><li><a href="18-physics.html#.3-Additional-Expression-Types-1">18.3 Additional Expression Types</a></li><li><a href="18-physics.html#.4-Trace-Calculations-1">18.4 Trace Calculations</a></li><li><a href="18-physics.html#.5-Mass-Declarations-1">18.5 Mass Declarations</a></li><li><a href="18-physics.html#.6-Example-1">18.6 Example</a></li><li><a href="18-physics.html#.7-Extensions-to-More-Than-Four-Dimensions-1">18.7 Extensions to More Than Four Dimensions</a></li></ul></ul><h2><a class="nav-anchor" id=".1-High-Energy-Physics-Operators-1" href="#.1-High-Energy-Physics-Operators-1">18.1 High Energy Physics Operators</a></h2><p>We begin by introducing three new operators required in these calculations.</p><h3><a class="nav-anchor" id=".1.1-.-(Cons)-Operator-1" href="#.1.1-.-(Cons)-Operator-1">18.1.1 . (Cons) Operator</a></h3><p>Syntax:</p><pre><code class="language-none">        (EXPRN1:vector_expression)  
                 . (EXPRN2:vector_expression):algebraic.</code></pre><p>The binary <code>.</code> operator, which is normally used to denote the addition of an element to the front of a list, can also be used in algebraic mode to denote the scalar product of two Lorentz four-vectors. For this to happen, the second argument must be recognizable as a vector expression at the time of evaluation. With this meaning, this operator is often referred to as the <em>dot</em> operator. In the present system, the index handling routines all assume that Lorentz four-vectors are used, but these routines could be rewritten to handle other cases.</p><p>Components of vectors can be represented by including representations of unit vectors in the system. Thus if <code>eo</code> represents the unit vector <code>(1,0,0,0)</code>, <code>(p.eo)</code> represents the zeroth component of the four-vector <code>p</code>. Our metric and notation follows Bjorken and Drell “Relativistic Quantum Mechanics” (McGraw-Hill, New York, 1965). Similarly, an arbitrary component <code>p</code> may be represented by <code>(p.u)</code>. If contraction over components of vectors is required, then the declaration <code>index</code> must be used. Thus</p><pre><code class="language-none">Algebra.index(:u)</code></pre><p>declares <code>u</code> as an index, and the simplification of</p><pre><code class="language-none">        p.u * q.u</code></pre><p>would result in</p><pre><code class="language-none">        P.Q</code></pre><p>The metric tensor <span>$g^{μν}$</span> may be represented by <code>(u.v)</code>. If contraction over <code>u</code> and <code>v</code> is required, then they should be declared as indices.</p><p>Errors occur if indices are not properly matched in expressions.</p><p>If a user later wishes to remove the index property from specific vectors, he can do it with the declaration <code>remind</code>. Thus <code>Algebra.remind(v1,…,vn)</code> removes the index flags from the variables <code>v1</code> through <code>vn</code>. However, these variables remain vectors in the system.</p><h3><a class="nav-anchor" id=".1.2-G-Operator-for-Gamma-Matrices-1" href="#.1.2-G-Operator-for-Gamma-Matrices-1">18.1.2 G Operator for Gamma Matrices</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.g" href="#Reduce.Algebra.g"><code>Reduce.Algebra.g</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">g(id,exprn...)</code></pre><p>Syntax:</p><pre><code class="language-none">        G(ID:identifier[,EXPRN:vector_expression])  
                :gamma_matrix_expression.</code></pre><p><code>g</code> is an n-ary operator used to denote a product of γ matrices contracted with Lorentz four-vectors. Gamma matrices are associated with fermion lines in a Feynman diagram. If more than one such line occurs, then a different set of γ matrices (operating in independent spin spaces) is required to represent each line. To facilitate this, the first argument of <code>g</code> is a line identification identifier (not a number) used to distinguish different lines.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/d6ec549d281933c36ecb84d50203ffd785808bc3/src/args.jl#L1170-L1179">source</a></section><p>Thus</p><pre><code class="language-none">        g(l1,p) * g(l2,q)</code></pre><p>denotes the product of <code>γ.p</code> associated with a fermion line identified as <code>l1</code>, and <code>γ.q</code> associated with another line identified as <code>l2</code> and where <code>p</code> and <code>q</code> are Lorentz four-vectors. A product of γ matrices associated with the same line may be written in a contracted form.</p><p>Thus</p><pre><code class="language-none">        g(l1,p1,p2,...,p3) = g(l1,p1)*g(l1,p2)*...*g(l1,p3) .</code></pre><p>The vector <code>a</code> is reserved in arguments of <code>g</code> to denote the special <span>$γ$</span> matrix <span>$γ^5$</span>. Thus</p><pre><code class="language-none">g(l,a)	= γ ^ 5	associated with the line L
 	 	 
g(l,p,a)	= γ ⋅ p × γ ^ 5	associated with the line L.</code></pre><p><span>$γ^μ$</span> (associated with the line <code>L</code>) may be written as <code>g(l,u)</code>, with <code>u</code> flagged as an index if contraction over <code>u</code> is required.</p><p>The notation of Bjorken and Drell is assumed in all operations involving γ matrices.</p><h3><a class="nav-anchor" id=".1.3-EPS-Operator-1" href="#.1.3-EPS-Operator-1">18.1.3 EPS Operator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.eps" href="#Reduce.Algebra.eps"><code>Reduce.Algebra.eps</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eps(exprn1,...,exprn4)</code></pre><p>Syntax:</p><pre><code class="language-none">         EPS(EXPRN1:vector_expression,...,EXPRN4:vector_exp):vector_exp.</code></pre><p>The operator <code>eps</code> has four arguments, and is used only to denote the completely antisymmetric tensor of order 4 and its contraction with Lorentz four-vectors. Thus</p><div>\[ϵ_{ijkl} = \begin{cases} +1 &amp; \text{if }i,j,k,l\text{ is an even permutation of 0,1,2,3} \\ - 1  &amp; \text{if }i,j,k,l\text{ is an odd permutation of 0,1,2,3} \\ 0 &amp; \text{otherwise} \end{cases}.\]</div><p>A contraction of the form <span>$ϵ_{ijμν}p_μq_ν$</span> may be written as <code>eps(i,j,p,q)</code>, with <code>i</code> and <code>j</code> flagged as indices, and so on.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/d6ec549d281933c36ecb84d50203ffd785808bc3/src/args.jl#L1181-L1193">source</a></section><h2><a class="nav-anchor" id=".2-Vector-Variables-1" href="#.2-Vector-Variables-1">18.2 Vector Variables</a></h2><p>Apart from the line identification identifier in the <code>g</code> operator, all other arguments of the operators in this section are vectors. Variables used as such must be declared so by the type declaration <code>vector</code>, for example:</p><pre><code class="language-Julia">Algebra.vector(:p1,:p2)</code></pre><p>declares <code>p1</code> and <code>p2</code> to be vectors. Variables declared as indices or given a mass are automatically declared vector by these declarations.</p><h2><a class="nav-anchor" id=".3-Additional-Expression-Types-1" href="#.3-Additional-Expression-Types-1">18.3 Additional Expression Types</a></h2><p>Two additional expression types are necessary for high energy calculations, namely</p><h3><a class="nav-anchor" id=".3.1-Vector-Expressions-1" href="#.3.1-Vector-Expressions-1">18.3.1 Vector Expressions</a></h3><p>These follow the normal rules of vector combination. Thus the product of a scalar or numerical expression and a vector expression is a vector, as are the sum and difference of vector expressions. If these rules are not followed, error messages are printed. Furthermore, if the system finds an undeclared variable where it expects a vector variable, it will ask the user in interactive mode whether to make that variable a vector or not. In batch mode, the declaration will be made automatically and the user informed of this by a message.</p><p><em>Examples:</em> Assuming <code>p</code> and <code>q</code> have been declared vectors, the following are vector expressions</p><pre><code class="language-none">        p  
        2*q/3  
        2*x*y*p - p.q*q/(3*q.q)</code></pre><p>whereas <code>p*q</code> and <code>p/q</code> are not.</p><h3><a class="nav-anchor" id=".3.2-Dirac-Expressions-1" href="#.3.2-Dirac-Expressions-1">18.3.2 Dirac Expressions</a></h3><p>These denote those expressions which involve γ matrices. A γ matrix is implicitly a 4 × 4 matrix, and so the product, sum and difference of such expressions, or the product of a scalar and Dirac expression is again a Dirac expression. There are no Dirac variables in the system, so whenever a scalar variable appears in a Dirac expression without an associated γ matrix expression, an implicit unit 4 by 4 matrix is assumed. For example, <code>g(l,p) + m</code> denotes <code>g(l,p) + m*⟨unit 4 by 4 matrix⟩</code>. Multiplication of Dirac expressions, as for matrix expressions, is of course non-commutative.</p><h2><a class="nav-anchor" id=".4-Trace-Calculations-1" href="#.4-Trace-Calculations-1">18.4 Trace Calculations</a></h2><p>When a Dirac expression is evaluated, the system computes one quarter of the trace of each γ matrix product in the expansion of the expression. One quarter of each trace is taken in order to avoid confusion between the trace of the scalar <code>m</code>, say, and <code>m</code> representing <code>m * ⟨unit 4 by 4 matrix⟩</code>. Contraction over indices occurring in such expressions is also performed. If an unmatched index is found in such an expression, an error occurs.</p><p>The algorithms used for trace calculations are the best available at the time this system was produced. For example, in addition to the algorithm developed by Chisholm for contracting indices in products of traces, REDUCE uses the elegant algorithm of Kahane for contracting indices in γ matrix products. These algorithms are described in Chisholm, J. S. R., Il Nuovo Cimento X, 30, 426 (1963) and Kahane, J., Journal Math. Phys. 9, 1732 (1968).</p><p>It is possible to prevent the trace calculation over any line identifier by the declaration <code>nospur</code>. For example,</p><pre><code class="language-Julia">Algebra.nospur(:l1,:l2)</code></pre><p>will mean that no traces are taken of γ matrix terms involving the line numbers <code>l1</code> and <code>l2</code>. However, in some calculations involving more than one line, a catastrophic error</p><pre><code class="language-none">        This NOSPUR option not implemented</code></pre><p>can occur (for the reason stated!) If you encounter this error, please let us know!</p><p>A trace of a γ matrix expression involving a line identifier which has been declared <code>nospur</code> may be later taken by making the declaration <code>spur</code>.</p><p>See also the CVIT package for an alternative mechanism (chapter 16.17).</p><h2><a class="nav-anchor" id=".5-Mass-Declarations-1" href="#.5-Mass-Declarations-1">18.5 Mass Declarations</a></h2><p>It is often necessary to put a particle “on the mass shell” in a calculation. This can, of course, be accomplished with a <code>let</code> command such as</p><pre><code class="language-none">        let p.p= m^2;</code></pre><p>but an alternative method is provided by two commands <code>mass</code> and <code>mshell</code>. <code>mass</code> takes a list of equations of the form:</p><pre><code class="language-none">⟨vector variable⟩=⟨scalar variable⟩</code></pre><p>for example,</p><pre><code class="language-Julia">Algebra.mass(:(p1==m), :(q1==mu))</code></pre><p>The only effect of this command is to associate the relevant scalar variable as a mass with the corresponding vector. If we now say</p><pre><code class="language-none">mshell ⟨vector variable⟩,…,⟨vector variable⟩⟨terminator⟩</code></pre><p>and a mass has been associated with these arguments, a substitution of the form</p><pre><code class="language-none">⟨vector variable⟩.⟨vector variable⟩ = ⟨mass⟩^2</code></pre><p>is set up. An error results if the variable has no preassigned mass.</p><h2><a class="nav-anchor" id=".6-Example-1" href="#.6-Example-1">18.6 Example</a></h2><p>Not initially supported by Reduce.jl parser, see <a href="http://www.reduce-algebra.com/manual/manualse185.html">upstream docs</a> for more information.</p><h2><a class="nav-anchor" id=".7-Extensions-to-More-Than-Four-Dimensions-1" href="#.7-Extensions-to-More-Than-Four-Dimensions-1">18.7 Extensions to More Than Four Dimensions</a></h2><p>In our discussion so far, we have assumed that we are working in the normal four dimensions of QED calculations. However, in most cases, the programs will also work in an arbitrary number of dimensions. The command</p><pre><code class="language-none">vecdim ⟨expression⟩⟨terminator⟩</code></pre><p>sets the appropriate dimension. The dimension can be symbolic as well as numerical. Users should note however, that the <code>eps</code> operator and the <span>$γ_5$</span> symbol (<code>a</code>) are not properly defined in other than four dimensions and will lead to an error if used.</p><footer><hr/><a class="previous" href="17-symbolic.html"><span class="direction">Previous</span><span class="title">17 Symbolic Mode</span></a><a class="next" href="19-rlisp.html"><span class="direction">Next</span><span class="title">19 REDUCE and Rlisp Utilities</span></a></footer></article></body></html>
