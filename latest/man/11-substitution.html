<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>11 Substitution Commands · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../library.html">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="acknowledgement.html">Acknowledgement</a></li><li><a class="toctext" href="01-introduction.html">1 Introductory Information</a></li><li><a class="toctext" href="02-structure.html">2 Structure of Programs</a></li><li><a class="toctext" href="03-expressions.html">3 Expressions</a></li><li><a class="toctext" href="04-lists.html">4 Lists</a></li><li><a class="toctext" href="05-statements.html">5 Statements</a></li><li><a class="toctext" href="06-commands-declarations.html">6 Commands and Declarations</a></li><li><a class="toctext" href="07-prefix-ops.html">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="08-display.html">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="09-polynomials.html">9 Polynomials and Rationals</a></li><li><a class="toctext" href="10-properties.html">10 Assigning and Testing Algebraic Properties</a></li><li class="current"><a class="toctext" href="11-substitution.html">11 Substitution Commands</a><ul class="internal"><li><a class="toctext" href="#.1-SUB-Operator-1">11.1 SUB Operator</a></li><li><a class="toctext" href="#.2-LET-Rules-1">11.2 LET Rules</a></li><li><a class="toctext" href="#.3-Rule-Lists-1">11.3 Rule Lists</a></li><li><a class="toctext" href="#.4-Asymptotic-Commands-1">11.4 Asymptotic Commands</a></li></ul></li><li><a class="toctext" href="12-file-io.html">12 File Handling Commands</a></li><li><a class="toctext" href="13-interactive.html">13 Commands for Interactive Use</a></li><li><a class="toctext" href="14-matrix.html">14 Matrix Calculations</a></li><li><a class="toctext" href="15-procedures.html">15 Procedures</a></li><li><a class="toctext" href="16-packages.html">16 User Contributed Packages</a></li><li><a class="toctext" href="20-maintaining.html">20 Maintaining REDUCE</a></li><li><a class="toctext" href="A-reserved.html">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="B-bibliography.html">Appendix B: Bibliography</a></li><li><a class="toctext" href="C-changelog.html">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="index.html">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href="11-substitution.html">11 Substitution Commands</a></li></ul><a class="edit-page" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/11-substitution.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>11 Substitution Commands</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Substitution-Commands-1" href="#Substitution-Commands-1">11 Substitution Commands</a></h1><p>An important class of commands in REDUCE define substitutions for variables and expressions to be made during the evaluation of expressions. Such substitutions use the prefix operator SUB, various forms of the command <code>let</code>, and rule sets.</p><ul><li><a href="11-substitution.html#Substitution-Commands-1">11 Substitution Commands</a></li><ul><li><a href="11-substitution.html#.1-SUB-Operator-1">11.1 SUB Operator</a></li><li><a href="11-substitution.html#.2-LET-Rules-1">11.2 LET Rules</a></li><li><a href="11-substitution.html#.3-Rule-Lists-1">11.3 Rule Lists</a></li><li><a href="11-substitution.html#.4-Asymptotic-Commands-1">11.4 Asymptotic Commands</a></li></ul></ul><h2><a class="nav-anchor" id=".1-SUB-Operator-1" href="#.1-SUB-Operator-1">11.1 SUB Operator</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.sub" href="#Reduce.Algebra.sub"><code>Reduce.Algebra.sub</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sub(::Union{Dict,Pair},expr)</code></pre><p>Make variable substitutions using Reduce&#39;s native sub command. Syntax:</p><pre><code class="language-none">R&quot;(⟨substitution_list⟩,⟨EXPRN1:algebraic⟩)&quot;</code></pre><p>where <code>⟨substitution_list⟩</code> is a list of one or more equations of the form</p><pre><code class="language-none">⟨VAR:kernel⟩ = ⟨EXPRN:algebraic⟩</code></pre><p>or a kernel that evaluates to such a list.</p><p>The <code>sub</code> operator gives the algebraic result of replacing every occurrence of the variable <code>var</code> in the expression <code>EXPRN1</code> by the expression <code>EXPRN</code>. Specifically, <code>EXPRN1</code> is first evaluated using all available rules. Next the substitutions are made, and finally the substituted expression is reevaluated. When more than one variable occurs in the substitution list, the substitution is performed by recursively walking down the tree representing <code>EXPRN1</code>, and replacing every <code>VAR</code> found by the appropriate <code>EXPRN</code>. The <code>EXPRN</code> are not themselves searched for any occurrences of the various <code>VAR</code>s. The trivial case <code>sub</code>(EXPRN1)<code>returns the algebraic value of</code>EXPRN1`.</p><p><em>Examples:</em></p><pre><code class="language-Julia">julia&gt; Algebra.sub((:(x=a+y),:(y=y+1)),:(x^2+y^2))
:((a + y) ^ 2 + (y + 1) ^ 2)</code></pre><p>and with <code>@rcall s = (x=a+y,y=y+1)</code>,</p><pre><code class="language-none">julia&gt; Algebra.sub(:s,:(x^2+y^2))
:((a + y) ^ 2 + (y + 1) ^ 2)</code></pre><p>Note that the global assignments <code>R&quot;x:=a+y&quot;</code>, etc., do not take place.</p><p><code>EXPRN1</code> can be any valid algebraic expression whose type is such that a substitution process is defined for it (e.g., scalar expressions, lists and matrices). An error will occur if an expression of an invalid type for substitution occurs either in <code>EXPRN</code> or <code>EXPRN1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/args.jl#L224-L252">source</a><div><pre><code class="language-none">sub(T::DataType,expr::Expr)</code></pre><p>Make a substitution to convert numerical values to type T</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/args.jl#L262-L266">source</a></section><p>The braces around the substitution list may also be omitted, as in:</p><pre><code class="language-none">                                    2              2  
     sub(x=a+y,y=y+1,x^2+y^2)   -&gt; A  + 2*A*Y + 2*Y  + 2*Y + 1</code></pre><h2><a class="nav-anchor" id=".2-LET-Rules-1" href="#.2-LET-Rules-1">11.2 LET Rules</a></h2><p>Unlike substitutions introduced via <code>sub</code>, <code>let</code> rules are global in scope and stay in effect until replaced or <code>clear</code>ed.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.rlet" href="#Reduce.Algebra.rlet"><code>Reduce.Algebra.rlet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rlet(::Union{Dict,Pair},expr)</code></pre><p>The simplest use of the <code>let</code> statement is in the form</p><pre><code class="language-none">R&quot;let ⟨substitution list⟩&quot;</code></pre><p>where <code>⟨substitution list⟩</code> is a list of rules separated by commas, each of the form:</p><pre><code class="language-none">⟨variable⟩ = ⟨expression⟩</code></pre><p>or</p><pre><code class="language-none">⟨prefix operator⟩(⟨argument⟩,…,⟨argument⟩) = ⟨expression⟩</code></pre><p>or</p><pre><code class="language-none">⟨argument⟩⟨infix operator⟩,…,⟨argument⟩ = ⟨expression⟩</code></pre><p>For example,</p><pre><code class="language-none">        let {x =&gt; y^2,
             h(u,v) =&gt; u - v,
             cos(pi/3) =&gt; 1/2,
             a*b =&gt; c,
             l+m =&gt; n,
             w^3 =&gt; 2*z - 3,
             z^10 =&gt; 0}</code></pre><p>The list brackets can be left out if preferred. The above rules could also have been entered as seven separate <code>let</code> statements.</p><p>After such <code>let</code> rules have been input, <code>x</code> will always be evaluated as the square of <code>y</code>, and so on. This is so even if at the time the <code>let</code> rule was input, the variable <code>y</code> had a value other than <code>y</code>. (In contrast, the assignment <code>R&quot;x:=y^2&quot;</code> will set <code>x</code> equal to the square of the current value of <code>y</code>, which could be quite different.)</p><p>The rule <code>let a*b=c</code> means that whenever <code>a</code> and <code>b</code> are both factors in an expression their product will be replaced by <code>c</code>. For example, <code>a^5*b^7*w</code> would be replaced by <code>c^5*b^2*w</code>.</p><p>The rule for <code>l+m</code> will not only replace all occurrences of <code>l+m</code> by <code>n</code>, but will also normally replace <code>l</code> by <code>n-m</code>, but not <code>m</code> by <code>n-l</code>. A more complete description of this case is given in Section 11.2.5.</p><p>The rule pertaining to <code>w^3</code> will apply to any power of <code>w</code> greater than or equal to the third.</p><p>Note especially the last example, <code>let z^10=0</code>. This declaration means, in effect: ignore the tenth or any higher power of <code>z</code>. Such declarations, when appropriate, often speed up a computation to a considerable degree. (See Section 11.4 for more details.)</p><p>Any new operators occurring in such <code>let</code> rules will be automatically declared <code>operator</code> by the system, if the rules are being read from a file. If they are being entered interactively, the system will ask <code>Declare… Operator?</code>. Answer <code>Y</code> or <code>N</code> and hit <code>&lt;Return&gt;</code>.</p><p>In each of these examples, substitutions are only made for the explicit expressions given; i.e., none of the variables may be considered arbitrary in any sense. For example, the command</p><pre><code class="language-Julia">julia&gt; Algebra.rlet( :(h(u,v)) =&gt; :(u - v) )</code></pre><p>will cause <code>h(u,v)</code> to evaluate to <code>u - v</code>, but will not affect <code>h(u,z)</code> or <code>h</code> with any arguments other than precisely the symbols <code>u,v</code>.</p><p>These simple <code>let</code> rules are on the same logical level as assignments made with the <code>:=</code> operator. An assignment <code>R&quot;x := p+q&quot;</code> cancels a rule <code>rlet( :x =&gt; :(y^2) )</code> made earlier, and vice versa.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/unary.jl#L211-L261">source</a></section><p><em>CAUTION:</em> A recursive rule such as</p><pre><code class="language-Julia">julia&gt; Algebra.rlet( :x =&gt; :(x + 1) )</code></pre><p>is erroneous, since any subsequent evaluation of <code>x</code> would lead to a non-terminating chain of substitutions:</p><pre><code class="language-none">      x -&gt; x + 1 -&gt; (x + 1) + 1 -&gt; ((x + 1) + 1) + 1 -&gt; ...</code></pre><p>Similarly, coupled substitutions such as</p><pre><code class="language-none">julia&gt; Algebra.rlet([:l =&gt; :(m + n), :n =&gt; :(l + r)])</code></pre><p>would lead to the same error. As a result, if you try to evaluate an <code>x</code>, <code>l</code> or <code>n</code> defined as above, you will get an error such as</p><pre><code class="language-none">        X improperly defined in terms of itself</code></pre><p>Array and matrix elements can appear on the left-hand side of a <code>let</code> statement. However, because of their instant evaluation property, it is the value of the element that is substituted for, rather than the element itself. E.g.,</p><pre><code class="language-none">        array a(5);  
        a(2) := b;  
        let a(2) = c;</code></pre><p>results in <code>b</code> being substituted by <code>c</code>; the assignment for <code>a(2)</code> does not change.</p><p>Finally, if an error occurs in any equation in a <code>let</code> statement (including generalized statements involving <code>for all</code> and <code>such that</code>), the remaining rules are not evaluated.</p><h3><a class="nav-anchor" id=".2.1-FOR-ALL-…-LET-1" href="#.2.1-FOR-ALL-…-LET-1">11.2.1 FOR ALL … LET</a></h3><p>If a substitution for all possible values of a given argument of an operator is required, the declaration FOR ALL may be used. The syntax of such a command is</p><pre><code class="language-Julia">R&quot;for all ⟨variable⟩,…,⟨variable⟩ ⟨LET statement⟩⟨terminator⟩&quot;</code></pre><p>e.g.,</p><pre><code class="language-Julia">R&quot;for all x,y let h(x,y) = x-y&quot;
R&quot;for all x let k(x,y) = x^y&quot;</code></pre><p>The first of these declarations would cause <code>h(a,b)</code> to be evaluated as <code>a-b</code>, <code>h(u+v,u+w)</code> to be <code>v-w</code>, etc. If the operator symbol <code>h</code> is used with more or fewer argument places, not two, the <code>let</code> would have no effect, and no error would result.</p><p>The second declaration would cause <code>k(a,y)</code> to be evaluated as <code>a^y</code>, but would have no effect on <code>k(a,z)</code> since the rule didn’t say <code>for all y…</code>.</p><p>Where we used <code>x</code> and <code>y</code> in the examples, any variables could have been used. This use of a variable doesn’t affect the value it may have outside the <code>let</code> statement. However, you should remember what variables you actually used. If you want to delete the rule subsequently, you must use the same variables in the <code>clear</code> command.</p><p>It is possible to use more complicated expressions as a template for a <code>let</code> statement, as explained in the section on substitutions for general expressions. In nearly all cases, the rule will be accepted, and a consistent application made by the system. However, if there is a sole constant or a sole free variable on the left-hand side of a rule (e.g., <code>R&quot;let 2=3 or for all x let x=2&quot;</code>), then the system is unable to handle the rule, and the error message</p><pre><code class="language-none">        Substitution for ... not allowed</code></pre><p>will be issued. Any variable listed in the <code>for all</code> part will have its symbol preceded by an equal sign: <code>x</code> in the above example will appear as <code>=x</code>. An error will also occur if a variable in the <code>for all</code> part is not properly matched on both sides of the <code>let</code> equation.</p><h3><a class="nav-anchor" id=".2.2-FOR-ALL-…-SUCH-THAT-…-LET-1" href="#.2.2-FOR-ALL-…-SUCH-THAT-…-LET-1">11.2.2 FOR ALL … SUCH THAT … LET</a></h3><p>If a substitution is desired for more than a single value of a variable in an operator or other expression, but not all values, a conditional form of the <code>for all … let</code> declaration can be used.</p><p><em>Example:</em></p><pre><code class="language-Julia">R&quot;for all x such that numberp x and x&lt;0 let h(x)=0&quot;</code></pre><p>will cause <code>h(-5)</code> to be evaluated as 0, but <code>h</code> of a positive integer, or of an argument that is not an integer at all, would not be affected. Any boolean expression can follow the <code>such that</code> keywords.</p><h3><a class="nav-anchor" id=".2.3-Removing-Assignments-and-Substitution-Rules-1" href="#.2.3-Removing-Assignments-and-Substitution-Rules-1">11.2.3 Removing Assignments and Substitution Rules</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.clear" href="#Reduce.Algebra.clear"><code>Reduce.Algebra.clear</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clear(r...)</code></pre><p>The user may remove all assignments and substitution rules from any expression by the command <code>clear</code>, in the form</p><pre><code class="language-none">R&quot;clear ⟨expression⟩,…,⟨expression⟩ = ⟨terminator⟩&quot;
e.g.</code></pre><p>Julia julia&gt; Algebra.clear(:x,:(h(x,y)))</p><pre><code class="language-none">Because of their *instant evaluation* property, array and matrix elements cannot be cleared with `clear`. For example, if `a` is an array, you must say</code></pre><p>Julia R&quot;a(3) := 0&quot;</p><pre><code class="language-none">rather than</code></pre><p>Julia R&quot;clear a(3)&quot; ``<code>to “clear” element</code>a(3)`.</p><p>On the other hand, a whole array (or matrix) <code>a</code> can be cleared by the command <code>clear(:a)</code>. This means much more than resetting to 0 all the elements of <code>a</code>. The fact that <code>a</code> is an array, and what its dimensions are, are forgotten, so <code>a</code> can be redefined as another type of object, for example an operator.</p><p>If you need to clear a variable whose name must be computed, see the <code>unset</code> statement.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/args.jl#L953-L976">source</a></section><p>The more general types of <code>let</code> declarations can also be deleted by using <code>clear</code>. Simply repeat the <code>let</code> rule to be deleted, using <code>clear</code> in place of <code>let</code>, and omitting the equal sign and right-hand part. The same dummy variables must be used in the <code>for all</code> part, and the boolean expression in the <code>such  that</code> part must be written the same way. (The placing of blanks doesn’t have to be identical.)</p><p><em>Example:</em> The <code>let</code> rule</p><pre><code class="language-Julia">R&quot;for all x such that numberp x and x&lt;0 let h(x)=0&quot;</code></pre><p>can be erased by the command</p><pre><code class="language-Julia">R&quot;for all x such that numberp x and x&lt;0 clear h(x)&quot;</code></pre><h3><a class="nav-anchor" id=".2.4-Overlapping-LET-Rules-1" href="#.2.4-Overlapping-LET-Rules-1">11.2.4 Overlapping LET Rules</a></h3><p><code>clear</code> is not the only way to delete a <code>let</code> rule. A new <code>let</code> rule identical to the first, but with a different expression after the equal sign, replaces the first. Replacements are also made in other cases where the existing rule would be in conflict with the new rule. For example, a rule for <code>x^4</code> would replace a rule for <code>x^5</code>. The user should however be cautioned against having several <code>let</code> rules in effect that relate to the same expression. No guarantee can be given as to which rules will be applied by REDUCE or in what order. It is best to <code>clear</code> an old rule before entering a new related <code>let</code> rule.</p><h3><a class="nav-anchor" id=".2.5-Substitutions-for-General-Expressions-1" href="#.2.5-Substitutions-for-General-Expressions-1">11.2.5 Substitutions for General Expressions</a></h3><p>The examples of substitutions discussed in other sections have involved very simple rules. However, the substitution mechanism used in REDUCE is very general, and can handle arbitrarily complicated rules without difficulty.</p><p>The general substitution mechanism used in REDUCE is discussed in Hearn, A. C., “REDUCE, A User-Oriented Interactive System for Algebraic Simplification,” Interactive Systems for Experimental Applied Mathematics, (edited by M. Klerer and J. Reinfelds), Academic Press, New York (1968), 79-90, and Hearn. A. C., “The Problem of Substitution,” Proc. 1968 Summer Institute on Symbolic Mathematical Computation, IBM Programming Laboratory Report FSC 69-0312 (1969). For the reasons given in these references, REDUCE does not attempt to implement a general pattern matching algorithm. However, the present system uses far more sophisticated techniques than those discussed in the above papers. It is now possible for the rules appearing in arguments of <code>let</code> to have the form</p><pre><code class="language-none">⟨substitution expression⟩ = ⟨expression⟩</code></pre><p>where any rule to which a sensible meaning can be assigned is permitted. However, this meaning can vary according to the form of <code>⟨substitution expression⟩</code>. The semantic rules associated with the application of the substitution are completely consistent, but somewhat complicated by the pragmatic need to perform such substitutions as efficiently as possible. The following rules explain how the majority of the cases are handled.</p><p>To begin with, the <code>⟨substitution expression⟩</code> is first partly simplified by collecting like terms and putting identifiers (and kernels) in the system order. However, no substitutions are performed on any part of the expression with the exception of expressions with the <em>instant evaluation</em> property, such as array and matrix elements, whose actual values are used. It should also be noted that the system order used is not changeable by the user, even with the <code>korder</code> command. Specific cases are then handled as follows:</p><ol><li><p>If the resulting simplified rule has a left-hand side that is an identifier, an expression with a top-level algebraic operator or a power, then the rule is added without further change to the appropriate table.</p></li><li><p>If the operator <code>*</code> appears at the top level of the simplified left-hand side, then any constant arguments in that expression are moved to the right-hand side of the rule. The remaining left-hand side is then added to the appropriate table. For example,</p></li></ol><pre><code class="language-Julia">julia&gt; Algebra.rlet(:(2*x*y) =&gt; 3)</code></pre><p>becomes</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:(x*y) =&gt; 3/2)</code></pre><p>so that <code>x*y</code> is added to the product substitution table, and when this rule is applied, the expression <code>x*y</code> becomes <code>3/2</code>, but <code>x</code> or <code>y</code> by themselves are not replaced.</p><ol><li><p>If the operators <code>+</code>, <code>-</code> or <code>/</code> appear at the top level of the simplified left-hand side, all but the first term is moved to the right-hand side of the rule. Thus the rules</p></li></ol><pre><code class="language-Julia">julia&gt; Algebra.rlet(:(l+m)=&gt;:n, :(x/2)=&gt;:y, :(a-b)=&gt;:c)</code></pre><p>become</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:l=&gt;:(n-m), :x=&gt;:(2*y), :a=:(c+b))</code></pre><p>One problem that can occur in this case is that if a quantified expression is moved to the right-hand side, a given free variable might no longer appear on the left-hand side, resulting in an error because of the unmatched free variable. E.g.,</p><pre><code class="language-Julia">R&quot;for all x,y let f(x)+f(y)=x*y&quot;</code></pre><p>would become</p><pre><code class="language-Julia">R&quot;for all x,y let f(x)=x*y-f(y)&quot;</code></pre><p>which no longer has <code>y</code> on both sides.</p><p>The fact that array and matrix elements are evaluated in the left-hand side of rules can lead to confusion at times. Consider for example the statements</p><pre><code class="language-Julia">R&quot;array a(5); let x+a(2)=3; let a(3)=4&quot;</code></pre><p>The left-hand side of the first rule will become <code>x</code>, and the second 0. Thus the first rule will be instantiated as a substitution for <code>x</code>, and the second will result in an error.</p><p>The order in which a list of rules is applied is not easily understandable without a detailed knowledge of the system simplification protocol. It is also possible for this order to change from release to release, as improved substitution techniques are implemented. Users should therefore assume that the order of application of rules is arbitrary, and program accordingly.</p><p>After a substitution has been made, the expression being evaluated is reexamined in case a new allowed substitution has been generated. This process is continued until no more substitutions can be made.</p><p>As mentioned elsewhere, when a substitution expression appears in a product, the substitution is made if that expression divides the product. For example, the rule</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:(a^2*c) =&gt; :(3*z))</code></pre><p>would cause <code>a^2*c*x</code> to be replaced by <code>3*z*x</code> and <code>a^2*c^2</code> by <code>3*z*c</code>. If the substitution is desired only when the substitution expression appears in a product with the explicit powers supplied in the rule, the command <code>match</code> should be used instead.</p><p>For example,</p><pre><code class="language-Julia">R&quot;match a^2*c = 3*z&quot;</code></pre><p>would cause <code>a^2*c*x</code> to be replaced by <code>3*z*x</code>, but <code>a^2*c^2</code> would not be replaced. <code>match</code> can also be used with the <code>for all</code> constructions described above.</p><p>To remove substitution rules of the type discussed in this section, the <code>clear</code> command can be used, combined, if necessary, with the same <code>for all</code> clause with which the rule was defined, for example:</p><pre><code class="language-Julia">R&quot;for all x clear log(e^x),e^log(x),cos(w*t+theta(x))&quot;</code></pre><p>Note, however, that the arbitrary variable names in this case must be the same as those used in defining the substitution.</p><h2><a class="nav-anchor" id=".3-Rule-Lists-1" href="#.3-Rule-Lists-1">11.3 Rule Lists</a></h2><p>Rule lists offer an alternative approach to defining substitutions that is different from either <code>sub</code> or <code>let</code>. In fact, they provide the best features of both, since they have all the capabilities of <code>let</code>, but the rules can also be applied locally as is possible with <code>sub</code>. In time, they will be used more and more in REDUCE. However, since they are relatively new, much of the REDUCE code you see uses the older constructs.</p><p>A rule list is a list of rules that have the syntax</p><pre><code class="language-none">     &lt;expression&gt; =&gt; &lt;expression&gt; (WHEN &lt;boolean expression&gt;)</code></pre><p>For example,</p><pre><code class="language-none">        {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2,  
         cos(~n*pi)      =&gt; (-1)^n when remainder(n,2)=0}</code></pre><p>The tilde preceding a variable marks that variable as free for that rule, much as a variable in a <code>for all</code> clause in a <code>let</code> statement. The first occurrence of that variable in each relevant rule must be so marked on input, otherwise inconsistent results can occur. For example, the rule list</p><pre><code class="language-none">        {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2,  
         cos(x)^2        =&gt; (1+cos(2x))/2}</code></pre><p>designed to replace products of cosines, would not be correct, since the second rule would only apply to the explicit argument <code>x</code>. Later occurrences in the same rule may also be marked, but this is optional (internally, all such rules are stored with each relevant variable explicitly marked). The optional <code>when</code> clause allows constraints to be placed on the application of the rule, much as the <code>such that</code> clause in a <code>let</code> statement.</p><p>A rule list may be named, for example</p><pre><code class="language-none">        trig1 := {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2,  
                  cos(~x)*sin(~y) =&gt; (sin(x+y)-sin(x-y))/2,  
                  sin(~x)*sin(~y) =&gt; (cos(x-y)-cos(x+y))/2,  
                  cos(~x)^2       =&gt; (1+cos(2*x))/2,  
                  sin(~x)^2       =&gt; (1-cos(2*x))/2};</code></pre><p>Such named rule lists may be inspected as needed. E.g., the command <code>R trig1&quot;</code> would cause the above list to be printed.</p><p>Rule lists may be used in two ways. They can be globally instantiated by means of the command <code>let</code>. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:trig1)</code></pre><p>would cause the above list of rules to be globally active from then on until cancelled by the command <code>clearrules</code>, as in</p><pre><code class="language-Julia">julia&gt; Algebra.clearrules(:trig1)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.clearrules" href="#Reduce.Algebra.clearrules"><code>Reduce.Algebra.clearrules</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">clearrules(r)</code></pre><p><code>clearrules</code> has the syntax</p><pre><code class="language-Julia">R&quot;clearrules &lt;rule list&gt;|&lt;name of rule list&gt;(,...)&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/unary.jl#L705-L712">source</a></section><p>The second way to use rule lists is to invoke them locally by means of a <code>where</code> clause. For example</p><pre><code class="language-none">        cos(a)*cos(b+c)  
           where {cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2};</code></pre><p>or</p><pre><code class="language-none">R&quot;cos(a)*sin(b) where trigrules&quot;</code></pre><p>The syntax of an expression with a <code>where</code> clause is:</p><pre><code class="language-none">        &lt;expression&gt;  
            WHERE &lt;rule&gt;|&lt;rule list&gt;(,&lt;rule&gt;|&lt;rule list&gt; ...)</code></pre><p>so the first example above could also be written</p><pre><code class="language-none">        cos(a)*cos(b+c)  
           where cos(~x)*cos(~y) =&gt; (cos(x+y)+cos(x-y))/2;</code></pre><p>The effect of this construct is that the rule list(s) in the <code>where</code> clause only apply to the expression on the left of <code>where</code>. They have no effect outside the expression. In particular, they do not affect previously defined <code>where</code> clauses or <code>let</code> statements. For example, the sequence</p><pre><code class="language-none">     let a=2;  
     a where a=&gt;4;  
     a;</code></pre><p>would result in the output</p><pre><code class="language-none">     4  
 
     2</code></pre><p>Although <code>where</code> has a precedence less than any other infix operator, it still binds higher than keywords such as <code>else</code>, <code>then</code>, <code>do</code>, <code>repeat</code> and so on. Thus the expression</p><pre><code class="language-Julia">R&quot;if a=2 then 3 else a+2 where a=3&quot;</code></pre><p>will parse as</p><pre><code class="language-Julia">R&quot;if a=2 then 3 else (a+2 where a=3)&quot;</code></pre><p><code>where</code> may be used to introduce auxiliary variables in symbolic mode expressions, as described in Section 17.4. However, the symbolic mode use has different semantics, so expressions do not carry from one mode to the other.</p><p><em>Compatibility Note:</em> In order to provide compatibility with older versions of rule lists released through the Network Library, it is currently possible to use an equal sign interchangeably with the replacement sign <code>=&gt;</code> in rules and <code>let</code> statements. However, since this will change in future versions, the replacement sign is preferable in rules and the equal sign in non-rule-based <code>let</code> statements.</p><h4><a class="nav-anchor" id="Advanced-Use-of-Rule-Lists-1" href="#Advanced-Use-of-Rule-Lists-1">Advanced Use of Rule Lists</a></h4><p>Some advanced features of the rule list mechanism make it possible to write more complicated rules than those discussed so far, and in many cases to write more compact rule lists. These features are:</p><ul><li><p>Free operators</p></li><li><p>Double slash operator</p></li><li><p>Double tilde variables.</p></li></ul><p>A <em>free operator</em> in the left hand side of a pattern will match any operator with the same number of arguments. The free operator is written in the same style as a variable. For example, the implementation of the product rule of differentiation can be written as:</p><pre><code class="language-none">operator diff, !~f, !~g;  
 
prule := {diff(~f(~x) * ~g(~x),x) =&gt;  
             diff(f(x),x) * g(x) + diff(g(x),x) * f(x)};  
 
let prule;  
 
diff(sin(z)*cos(z),z);  
 
         cos(z)*diff(sin(z),z) + diff(cos(z),z)*sin(z)</code></pre><p>The <em>double slash operator</em> may be used as an alternative to a single slash (quotient) in order to match quotients properly. E.g., in the example of the Gamma function above, one can use:</p><pre><code class="language-none">gammarule :=  
   {gamma(~z)//(~c*gamma(~zz))  =&gt; gamma(z)/(c*gamma(zz-1)*zz)  
                  when fixp(zz -z) and (zz -z) &gt;0,  
    gamma(~z)//gamma(~zz) =&gt; gamma(z)/(gamma(zz-1)*zz)  
                  when fixp(zz -z) and (zz -z) &gt;0};  
 
let gammarule;  
 
gamma(z)/gamma(z+3);  
 
          1  
----------------------  
  3      2  
 z  + 6*z  + 11*z + 6</code></pre><p>The above example suffers from the fact that two rules had to be written in order to perform the required operation. This can be simplified by the use of <em>double tilde variables</em>. E.g. the rule list</p><pre><code class="language-none"> GGrule :=  {  
    gamma(~z)//(~~c*gamma(~zz))  =&gt; gamma(z)/(c*gamma(zz-1)*zz)  
     when fixp(zz -z) and (zz -z) &gt;0};</code></pre><p>will implement the same operation in a much more compact way. In general, double tilde variables are bound to the neutral element with respect to the operation in which they are used.</p><pre><code class="language-none">Pattern given	Argument used	Binding
~z + ~~y	x	z=x; y=0
~z + ~~y	x+3	z=x; y=3 or z=3; y=x
~z * ~~y	x	z=x; y=1
~z * ~~y	x*3	z=x; y=3 or z=3; y=x
~z / ~~y	x	z=x; y=1
~z / ~~y	x/3	z=x; y=3</code></pre><p>Remarks: A double tilde variable as the numerator of a pattern is not allowed. Also, using double tilde variables may lead to recursion errors when the zero case is not handled properly.</p><pre><code class="language-none">let f(~~a * ~x,x)  =&gt; a * f(x,x) when freeof (a,x);  
 
f(z,z);  
 
***** f(z,z) improperly defined in terms of itself  
 
% BUT:  
 
let ff(~~a * ~x,x)  
       =&gt; a * ff(x,x) when freeof (a,x) and a neq 1;  
 
ff(z,z);  
                 ff(z,z)  
 
ff(3*z,z);  
                 3*ff(z,z)</code></pre><h4><a class="nav-anchor" id="Displaying-Rules-Associated-with-an-Operator-1" href="#Displaying-Rules-Associated-with-an-Operator-1">Displaying Rules Associated with an Operator</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.showrules" href="#Reduce.Algebra.showrules"><code>Reduce.Algebra.showrules</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">showrules(r)</code></pre><p>The operator <code>showrules</code> takes a single identifier as argument, and returns in rule-list form the operator rules associated with that argument. For example:</p><pre><code class="language-Julia">reduce&gt; showrules log;  
 
{log(e) =&gt; 1,  
 
 log(1) =&gt; 0,  
 
      ~x  
 log(e  ) =&gt; ~x,  
 
                    1  
 df(log(~x),~x) =&gt; ----}  
                    ~x</code></pre><p>Such rules can then be manipulated further as with any list. For example <code>R&quot;rhs first ws&quot;</code> has the value <code>1</code>. Note that an operator may have other properties that cannot be displayed in such a form, such as the fact it is an odd function, or has a definition defined as a procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/4bdd75c3122805a4dfd65e9a1c3e76a0ef1e28a0/src/unary.jl#L714-L733">source</a></section><h4><a class="nav-anchor" id="Order-of-Application-of-Rules-1" href="#Order-of-Application-of-Rules-1">Order of Application of Rules</a></h4><p>If rules have overlapping domains, their order of application is important. In general, it is very difficult to specify this order precisely, so that it is best to assume that the order is arbitrary. However, if only one operator is involved, the order of application of the rules for this operator can be determined from the following:</p><ol><li><p>Rules containing at least one free variable apply before all rules without free variables.</p></li><li><p>Rules activated in the most recent <code>let</code> command are applied first.</p></li><li><p><code>let</code> with several entries generate the same order of application as a corresponding sequence of commands with one rule or rule set each.</p></li><li><p>Within a rule set, the rules containing at least one free variable are applied in their given order. In other words, the first member of the list is applied first.</p></li><li><p>Consistent with the first item, any rule in a rule list that contains no free variables is applied after all rules containing free variables.</p></li></ol><p><em>Example:</em> The following rule set enables the computation of exact values of the Gamma function:</p><pre><code class="language-none">        operator gamma,gamma_error;  
        gamma_rules :=  
        {gamma(~x)=&gt;sqrt(pi)/2 when x=1/2,  
         gamma(~n)=&gt;factorial(n-1) when fixp n and n&gt;0,  
         gamma(~n)=&gt;gamma_error(n) when fixp n,  
         gamma(~x)=&gt;(x-1)*gamma(x-1) when fixp(2*x) and x&gt;1,  
         gamma(~x)=&gt;gamma(x+1)/x when fixp(2*x)};</code></pre><p>Here, rule by rule, cases of known or definitely uncomputable values are sorted out; e.g. the rule leading to the error expression will be applied for negative integers only, since the positive integers are caught by the preceding rule, and the last rule will apply for negative odd multiples of 1∕2 only. Alternatively the first rule could have been written as</p><pre><code class="language-none">        gamma(1/2) =&gt; sqrt(pi)/2</code></pre><p>but then the case <span>$x = 1∕2$</span> should be excluded in the <code>when</code> part of the last rule explicitly because a rule without free variables cannot take precedence over the other rules.</p><h2><a class="nav-anchor" id=".4-Asymptotic-Commands-1" href="#.4-Asymptotic-Commands-1">11.4 Asymptotic Commands</a></h2><p>In expansions of polynomials involving variables that are known to be small, it is often desirable to throw away all powers of these variables beyond a certain point to avoid unnecessary computation. The command <code>let</code> may be used to do this. For example, if only powers of <code>x</code> up to <code>x^7</code> are needed, the command</p><pre><code class="language-Julia">julia&gt; Algebra.rlet(:(x^8) =&gt; 0)</code></pre><p>will cause the system to delete all powers of <code>x</code> higher than 7.</p><p><em>CAUTION:</em> This particular simplification works differently from most substitution mechanisms in REDUCE in that it is applied during polynomial manipulation rather than to the whole evaluated expression. Thus, with the above rule in effect, <code>x^10/x^5</code> would give the result zero, since the numerator would simplify to zero. Similarly <code>x^20/x^10</code> would give a <code>Zero divisor</code> error message, since both numerator and denominator would first simplify to zero.</p><p>The method just described is not adequate when expressions involve several variables having different degrees of smallness. In this case, it is necessary to supply an asymptotic weight to each variable and count up the total weight of each product in an expanded expression before deciding whether to keep the term or not. There are two associated commands in the system to permit this type of asymptotic constraint. The command WEIGHT takes a list of equations of the form</p><pre><code class="language-none">⟨kernel form⟩ = ⟨number⟩</code></pre><p>where <code>⟨number⟩</code> must be a positive integer (not just evaluate to a positive integer). This command assigns the weight <code>⟨number⟩</code> to the relevant kernel form. A check is then made in all algebraic evaluations to see if the total weight of the term is greater than the weight level assigned to the calculation. If it is, the term is deleted. To compute the total weight of a product, the individual weights of each kernel form are multiplied by their corresponding powers and then added.</p><p>The weight level of the system is initially set to 1. The user may change this setting by the command</p><pre><code class="language-Julia">R&quot;wtlevel &lt;number&gt;&quot;</code></pre><p>which sets <code>⟨number⟩</code> as the new weight level of the system. <code>meta</code> must evaluate to a positive integer. <code>wtlevel</code> will also allow <code>nil</code> as an argument, in which case the current weight level is returned.</p><footer><hr/><a class="previous" href="10-properties.html"><span class="direction">Previous</span><span class="title">10 Assigning and Testing Algebraic Properties</span></a><a class="next" href="12-file-io.html"><span class="direction">Next</span><span class="title">12 File Handling Commands</span></a></footer></article></body></html>
