<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>14 Matrix Calculations · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../library.html">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="acknowledgement.html">Acknowledgement</a></li><li><a class="toctext" href="01-introduction.html">1 Introductory Information</a></li><li><a class="toctext" href="02-structure.html">2 Structure of Programs</a></li><li><a class="toctext" href="03-expressions.html">3 Expressions</a></li><li><a class="toctext" href="04-lists.html">4 Lists</a></li><li><a class="toctext" href="05-statements.html">5 Statements</a></li><li><a class="toctext" href="06-commands-declarations.html">6 Commands and Declarations</a></li><li><a class="toctext" href="07-prefix-ops.html">7 Built-in Prefix Operators</a></li><li><a class="toctext" href="08-display.html">8 Display and Structuring of Expressions</a></li><li><a class="toctext" href="09-polynomials.html">9 Polynomials and Rationals</a></li><li><a class="toctext" href="10-properties.html">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="11-substitution.html">11 Substitution Commands</a></li><li><a class="toctext" href="12-file-io.html">12 File Handling Commands</a></li><li><a class="toctext" href="13-interactive.html">13 Commands for Interactive Use</a></li><li class="current"><a class="toctext" href="14-matrix.html">14 Matrix Calculations</a><ul class="internal"><li><a class="toctext" href="#.1-MAT-Operator-1">14.1 MAT Operator</a></li><li><a class="toctext" href="#.2-Matrix-Variables-1">14.2 Matrix Variables</a></li><li><a class="toctext" href="#.3-Matrix-Expressions-1">14.3 Matrix Expressions</a></li><li><a class="toctext" href="#.4-Operators-with-Matrix-Arguments-1">14.4 Operators with Matrix Arguments</a></li><li><a class="toctext" href="#.5-Matrix-Assignments-1">14.5 Matrix Assignments</a></li><li><a class="toctext" href="#.6-Evaluating-Matrix-Elements-1">14.6 Evaluating Matrix Elements</a></li></ul></li><li><a class="toctext" href="15-procedures.html">15 Procedures</a></li><li><a class="toctext" href="16-packages.html">16 User Contributed Packages</a></li><li><a class="toctext" href="17-symbolic.html">17 Symbolic Mode</a></li><li><a class="toctext" href="18-physics.html">18 Calculations in High Energy Physics</a></li><li><a class="toctext" href="19-rlisp.html">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="20-maintaining.html">20 Maintaining REDUCE</a></li><li><a class="toctext" href="A-reserved.html">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="B-bibliography.html">Appendix B: Bibliography</a></li><li><a class="toctext" href="C-changelog.html">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="index.html">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href="14-matrix.html">14 Matrix Calculations</a></li></ul><a class="edit-page" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/14-matrix.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>14 Matrix Calculations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Matrix-Calculations-1" href="#Matrix-Calculations-1">14 Matrix Calculations</a></h1><p>A very powerful feature of REDUCE is the ease with which matrix calculations can be performed. To extend our syntax to this class of calculations we need to add another prefix operator, <code>mat</code>, and a further variable and expression type as follows:</p><ul><li><a href="14-matrix.html#Matrix-Calculations-1">14 Matrix Calculations</a></li><ul><li><a href="14-matrix.html#.1-MAT-Operator-1">14.1 MAT Operator</a></li><li><a href="14-matrix.html#.2-Matrix-Variables-1">14.2 Matrix Variables</a></li><li><a href="14-matrix.html#.3-Matrix-Expressions-1">14.3 Matrix Expressions</a></li><li><a href="14-matrix.html#.4-Operators-with-Matrix-Arguments-1">14.4 Operators with Matrix Arguments</a></li><li><a href="14-matrix.html#.5-Matrix-Assignments-1">14.5 Matrix Assignments</a></li><li><a href="14-matrix.html#.6-Evaluating-Matrix-Elements-1">14.6 Evaluating Matrix Elements</a></li></ul></ul><h2><a class="nav-anchor" id=".1-MAT-Operator-1" href="#.1-MAT-Operator-1">14.1 MAT Operator</a></h2><p>This prefix operator is used to represent n × m matrices. <code>mat</code> has <code>n</code> arguments interpreted as rows of the matrix, each of which is a list of m expressions representing elements in that row. For example, the matrix</p><pre><code class="language-Julia">julia&gt; [:a :b :c; :d :e :f]
2×3 Array{Symbol,2}:
 :a  :b  :c
 :d  :e  :f</code></pre><p>would be written as <code>R&quot;mat((a,b,c),(d,e,f))&quot;</code>.</p><p>Note that the single column matrix</p><pre><code class="language-Julia">julia&gt; [:x; :y]
2-element Array{Symbol,1}:
 :x
 :y</code></pre><p>becomes <code>R&quot;mat((x),(y))&quot;</code>. The inside parentheses are required to distinguish it from the single row matrix</p><pre><code class="language-Julia">julia&gt; [:x :y]
1×2 Array{Symbol,2}:
 :x  :y</code></pre><p>that would be written as <code>R&quot;mat((x,y))&quot;</code>.</p><h2><a class="nav-anchor" id=".2-Matrix-Variables-1" href="#.2-Matrix-Variables-1">14.2 Matrix Variables</a></h2><p>An identifier may be declared a matrix variable by the declaration <code>matrix</code>. The size of the matrix may be declared explicitly in the matrix declaration, or by default in assigning such a variable to a matrix expression. For example,</p><pre><code class="language-Julia">julia&gt; Algebra.matrix(:(x(2,1)),:(y(3,4)),:z)</code></pre><p>declares <code>x</code> to be a 2 x 1 (column) matrix, <code>y</code> to be a 3 x 4 matrix and <code>z</code> a matrix whose size is to be declared later.</p><p>Matrix declarations can appear anywhere in a program. Once a symbol is declared to name a matrix, it can not also be used to name an array, operator or a procedure, or used as an ordinary variable. It can however be redeclared to be a matrix, and its size may be changed at that time. Note however that matrices once declared are global in scope, and so can then be referenced anywhere in the program. In other words, a declaration within a block (or a procedure) does not limit the scope of the matrix to that block, nor does the matrix go away on exiting the block (use <code>clear</code> instead for this purpose). An element of a matrix is referred to in the expected manner; thus <code>x(1,1)</code> gives the first element of the matrix <code>x</code> defined above. References to elements of a matrix whose size has not yet been declared leads to an error. All elements of a matrix whose size is declared are initialized to 0. As a result, a matrix element has an <em>instant evaluation</em> property and cannot stand for itself. If this is required, then an operator should be used to name the matrix elements as in:</p><pre><code class="language-Julia">julia&gt; Algebra.matrix(:m); Algebra.operator(:x);  rcall(&quot;m := mat((x(1,1),x(1,2)))&quot;);</code></pre><h2><a class="nav-anchor" id=".3-Matrix-Expressions-1" href="#.3-Matrix-Expressions-1">14.3 Matrix Expressions</a></h2><p>These follow the normal rules of matrix algebra as defined by the following syntax:</p><pre><code class="language-none">⟨matrix expression⟩  ::=  MAT⟨matrix description⟩∣⟨matrix variable⟩∣
			⟨scalar expression⟩*⟨matrix expression⟩∣
			⟨matrix expression⟩*⟨matrix expression⟩∣
			⟨matrix expression⟩+⟨matrix expression⟩∣
			⟨matrix expression⟩^⟨integer⟩∣
			⟨matrix expression⟩/⟨matrix expression⟩</code></pre><p>Sums and products of matrix expressions must be of compatible size; otherwise an error will result during their evaluation. Similarly, only square matrices may be raised to a power. A negative power is computed as the inverse of the matrix raised to the corresponding positive power. <code>a/b</code> is interpreted as <code>a*b^(-1)</code>.</p><p><em>Examples:</em></p><p>Assuming <code>x</code> and <code>y</code> have been declared as matrices, the following are matrix expressions</p><pre><code class="language-none">        y  
        y^2*x-3*y^(-2)*x  
        y + mat((1,a),(b,c))/2</code></pre><p>The computation of the quotient of two matrices normally uses a two-step elimination method due to Bareiss. An alternative method using Cramer’s method is also available. This is usually less efficient than the Bareiss method unless the matrices are large and dense, although we have no solid statistics on this as yet. To use Cramer’s method instead, the switch <code>cramer</code> should be turned on.</p><h2><a class="nav-anchor" id=".4-Operators-with-Matrix-Arguments-1" href="#.4-Operators-with-Matrix-Arguments-1">14.4 Operators with Matrix Arguments</a></h2><p>The operator <code>length</code> applied to a matrix returns a list of the number of rows and columns in the matrix. Other operators useful in matrix calculations are defined in the following subsections. Attention is also drawn to the LINALG (section 16.37) and NORMFORM (section 16.42) packages.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.det" href="#Reduce.Algebra.det"><code>Reduce.Algebra.det</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">det(exprn)</code></pre><p>Syntax:</p><pre><code class="language-none">        det(EXPRN:matrix_expression):algebraic.</code></pre><p>The operator <code>det</code> is used to represent the determinant of a square matrix expression. E.g.,</p><pre><code class="language-none">Algebra.det(:(y^2))</code></pre><p>is a scalar expression whose value is the determinant of the square of the matrix <code>y</code>, and</p><pre><code class="language-none">Algebra.det([:a :b :c; :d :e :f; :g :h :j])</code></pre><p>is a scalar expression whose value is the determinant of the matrix</p><pre><code class="language-Julia">3×3 Array{Symbol,2}:
 :a  :b  :c
 :d  :e  :f
 :g  :h  :j</code></pre><p>Determinant expressions have the instant evaluation property. In other words, the statement</p><pre><code class="language-none">        let det mat((a,b),(c,d)) = 2;</code></pre><p>sets the value of the determinant to <code>2</code>, and does not set up a rule for the determinant itself.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/fcc9459a099b9bab2ef2e958438b92903061d92d/src/unary.jl#L735-L762">source</a></section><pre><code class="language-none">Reduce.Algebra.mateigen</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.tp" href="#Reduce.Algebra.tp"><code>Reduce.Algebra.tp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tp(exprn)</code></pre><p>Syntax:</p><pre><code class="language-none">        tp(EXPRN:matrix_expression):matrix.</code></pre><p>This operator takes a single matrix argument and returns its transpose.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/fcc9459a099b9bab2ef2e958438b92903061d92d/src/unary.jl#L174-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.trace" href="#Reduce.Algebra.trace"><code>Reduce.Algebra.trace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trace(exprn)</code></pre><p>Syntax:</p><pre><code class="language-none">        TRACE(EXPRN:matrix_expression):algebraic.</code></pre><p>The operator TRACE is used to represent the trace of a square matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/fcc9459a099b9bab2ef2e958438b92903061d92d/src/unary.jl#L764-L772">source</a></section><pre><code class="language-none">Reduce.Algebra.cofactor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.nullspace" href="#Reduce.Algebra.nullspace"><code>Reduce.Algebra.nullspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nullspace(exprn)</code></pre><p>Syntax:</p><pre><code class="language-none">        NULLSPACE(EXPRN:matrix_expression):list</code></pre><p><code>nullspace</code> calculates for a matrix <code>a</code> a list of linear independent vectors (a basis) whose linear combinations satisfy the equation <span>$Ax = 0$</span>. The basis is provided in a form such that as many upper components as possible are isolated.</p><p>Note that with <code>b := nullspace a</code> the expression <code>length b</code> is the <em>nullity</em> of <code>a</code>, and that <code>second length a - length b</code> calculates the <em>rank</em> of <code>a</code>. The rank of a matrix expression can also be found more directly by the <code>rank</code> operator described below.</p><p><em>Example:</em> The command</p><pre><code class="language-none">        nullspace mat((1,2,3,4),(5,6,7,8));</code></pre><p>gives the output</p><pre><code class="language-none">        {  
         [ 1  ]  
         [ 0  ]  
         [ - 3]  
         [ 2  ]  
         ,  
         [ 0  ]  
         [ 1  ]  
         [ - 2]  
         [ 1  ]  
         }</code></pre><p>In addition to the REDUCE matrix form, <code>nullspace</code> accepts as input a matrix given as a list of lists, that is interpreted as a row matrix. If that form of input is chosen, the vectors in the result will be represented by lists as well. This additional input syntax facilitates the use of <code>nullspace</code> in applications different from classical linear algebra.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/fcc9459a099b9bab2ef2e958438b92903061d92d/src/unary.jl#L774-L804">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.rank" href="#Reduce.Algebra.rank"><code>Reduce.Algebra.rank</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rank(exprn)</code></pre><p>Syntax:</p><pre><code class="language-none">        RANK(EXPRN:matrix_expression):integer</code></pre><p><code>rank</code> calculates the rank of its argument, that, like <code>nullspace</code> can either be a standard matrix expression, or a list of lists, that can be interpreted either as a row matrix or a set of equations.</p><p><em>Example:</em></p><pre><code class="language-Julia">Algebra.rank([:a :b :c; :d :e :f])</code></pre><p>returns the value <code>2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/fcc9459a099b9bab2ef2e958438b92903061d92d/src/unary.jl#L806-L820">source</a></section><h2><a class="nav-anchor" id=".5-Matrix-Assignments-1" href="#.5-Matrix-Assignments-1">14.5 Matrix Assignments</a></h2><p>Matrix expressions may appear in the right-hand side of assignment statements. If the left-hand side of the assignment, which must be a variable, has not already been declared a matrix, it is declared by default to the size of the right-hand side. The variable is then set to the value of the right-hand side.</p><p>Such an assignment may be used very conveniently to find the solution of a set of linear equations. For example, to find the solution of the following set of equations</p><pre><code class="language-none">        a11*x(1) + a12*x(2) = y1  
        a21*x(1) + a22*x(2) = y2</code></pre><p>we simply write</p><pre><code class="language-none">Algebra.:*(Algebra.inv([:a11 :a12; :a21 :a22]),[:y1,:y2])</code></pre><h2><a class="nav-anchor" id=".6-Evaluating-Matrix-Elements-1" href="#.6-Evaluating-Matrix-Elements-1">14.6 Evaluating Matrix Elements</a></h2><p>Once an element of a matrix has been assigned, it may be referred to in standard array element notation. Thus <code>y(2,1)</code> refers to the element in the second row and first column of the matrix <code>y</code>.</p><footer><hr/><a class="previous" href="13-interactive.html"><span class="direction">Previous</span><span class="title">13 Commands for Interactive Use</span></a><a class="next" href="15-procedures.html"><span class="direction">Next</span><span class="title">15 Procedures</span></a></footer></article></body></html>
