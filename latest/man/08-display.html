<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>8 Display and Structuring of Expressions · Reduce.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Reduce.jl logo"/></a><h1>Reduce.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../library.html">Library</a></li><li><span class="toctext">User&#39;s Manual</span><ul><li><a class="toctext" href="acknowledgement.html">Acknowledgement</a></li><li><a class="toctext" href="01-introduction.html">1 Introductory Information</a></li><li><a class="toctext" href="02-structure.html">2 Structure of Programs</a></li><li><a class="toctext" href="03-expressions.html">3 Expressions</a></li><li><a class="toctext" href="04-lists.html">4 Lists</a></li><li><a class="toctext" href="05-statements.html">5 Statements</a></li><li><a class="toctext" href="06-commands-declarations.html">6 Commands and Declarations</a></li><li><a class="toctext" href="07-prefix-ops.html">7 Built-in Prefix Operators</a></li><li class="current"><a class="toctext" href="08-display.html">8 Display and Structuring of Expressions</a><ul class="internal"><li><a class="toctext" href="#.1-Kernels-1">8.1 Kernels</a></li><li><a class="toctext" href="#.2-The-Expression-Workspace-1">8.2 The Expression Workspace</a></li><li><a class="toctext" href="#.3-Output-of-Expressions-1">8.3 Output of Expressions</a></li><li><a class="toctext" href="#.4-Changing-the-Internal-Order-of-Variables-1">8.4 Changing the Internal Order of Variables</a></li><li><a class="toctext" href="#.5-Obtaining-Parts-of-Algebraic-Expressions-1">8.5 Obtaining Parts of Algebraic Expressions</a></li></ul></li><li><a class="toctext" href="09-polynomials.html">9 Polynomials and Rationals</a></li><li><a class="toctext" href="10-properties.html">10 Assigning and Testing Algebraic Properties</a></li><li><a class="toctext" href="11-substitution.html">11 Substitution Commands</a></li><li><a class="toctext" href="12-file-io.html">12 File Handling Commands</a></li><li><a class="toctext" href="13-interactive.html">13 Commands for Interactive Use</a></li><li><a class="toctext" href="14-matrix.html">14 Matrix Calculations</a></li><li><a class="toctext" href="15-procedures.html">15 Procedures</a></li><li><a class="toctext" href="16-packages.html">16 User Contributed Packages</a></li><li><a class="toctext" href="17-symbolic.html">17 Symbolic Mode</a></li><li><a class="toctext" href="18-physics.html">18 Calculations in High Energy Physics</a></li><li><a class="toctext" href="19-rlisp.html">19 REDUCE and Rlisp Utilities</a></li><li><a class="toctext" href="20-maintaining.html">20 Maintaining REDUCE</a></li><li><a class="toctext" href="A-reserved.html">Appendix A: Reserved Identifiers</a></li><li><a class="toctext" href="B-bibliography.html">Appendix B: Bibliography</a></li><li><a class="toctext" href="C-changelog.html">Appendix C: Changes since Version 3.8</a></li><li><a class="toctext" href="index.html">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Manual</li><li><a href="08-display.html">8 Display and Structuring of Expressions</a></li></ul><a class="edit-page" href="https://github.com/chakravala/Reduce.jl/blob/master/docs/src/man/08-display.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>8 Display and Structuring of Expressions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Display-and-Structuring-of-Expressions-1" href="#Display-and-Structuring-of-Expressions-1">8 Display and Structuring of Expressions</a></h1><p>In this section, we consider a variety of commands and operators that permit the user to obtain various parts of algebraic expressions and also display their structure in a variety of forms. Also presented are some additional concepts in the REDUCE design that help the user gain a better understanding of the structure of the system.</p><ul><li><a href="08-display.html#Display-and-Structuring-of-Expressions-1">8 Display and Structuring of Expressions</a></li><ul><li><a href="08-display.html#.1-Kernels-1">8.1 Kernels</a></li><li><a href="08-display.html#.2-The-Expression-Workspace-1">8.2 The Expression Workspace</a></li><li><a href="08-display.html#.3-Output-of-Expressions-1">8.3 Output of Expressions</a></li><li><a href="08-display.html#.4-Changing-the-Internal-Order-of-Variables-1">8.4 Changing the Internal Order of Variables</a></li><li><a href="08-display.html#.5-Obtaining-Parts-of-Algebraic-Expressions-1">8.5 Obtaining Parts of Algebraic Expressions</a></li></ul></ul><h2><a class="nav-anchor" id=".1-Kernels-1" href="#.1-Kernels-1">8.1 Kernels</a></h2><p>REDUCE is designed so that each operator in the system has an evaluation (or simplification) function associated with it that transforms the expression into an internal canonical form. This form, which bears little resemblance to the original expression, is described in detail in Hearn, A. C., “REDUCE 2: A System and Language for Algebraic Manipulation,” Proc. of the Second Symposium on Symbolic and Algebraic Manipulation, ACM, New York (1971) 128-133.</p><p>The evaluation function may transform its arguments in one of two alternative ways. First, it may convert the expression into other operators in the system, leaving no functions of the original operator for further manipulation. This is in a sense true of the evaluation functions associated with the operators <code>+</code>, <code>*</code> and <code>/</code> , for example, because the canonical form does not include these operators explicitly. It is also true of an operator such as the determinant operator <code>det</code> because the relevant evaluation function calculates the appropriate determinant, and the operator <code>det</code> no longer appears. On the other hand, the evaluation process may leave some residual functions of the relevant operator. For example, with the operator <code>cos</code>, a residual expression like <code>cos(x)</code> may remain after evaluation unless a rule for the reduction of cosines into exponentials, for example, were introduced. These residual functions of an operator are termed kernels and are stored uniquely like variables. Subsequently, the kernel is carried through the calculation as a variable unless transformations are introduced for the operator at a later stage.</p><p>In those cases where the evaluation process leaves an operator expression with non-trivial arguments, the form of the argument can vary depending on the state of the system at the point of evaluation. Such arguments are normally produced in expanded form with no terms factored or grouped in any way. For example, the expression <code>cos(2*x+2*y)</code> will normally be returned in the same form. If the argument <code>2*x+2*y</code> were evaluated at the top level, however, it would be printed as <code>2*(x+y)</code>. If it is desirable to have the arguments themselves in a similar form, the switch <code>intstr</code> (for “internal structure”), if on, will cause this to happen. In cases where the arguments of the kernel operators may be reordered, the system puts them in a canonical order, based on an internal intrinsic ordering of the variables. However, some commands allow arguments in the form of kernels, and the user has no way of telling what internal order the system will assign to these arguments. To resolve this difficulty, we introduce the notion of a kernel form as an expression that transforms to a kernel on evaluation.</p><p>Examples of kernel forms are:</p><pre><code class="language-Julia">R&quot;a&quot;
R&quot;cos(x*y)&quot;
R&quot;log(sin(x))&quot;</code></pre><p>whereas</p><pre><code class="language-Julia">R&quot;a*b&quot;
R&quot;(a+b)^4&quot;</code></pre><p>are not.</p><p>We see that kernel forms can usually be used as generalized variables, and most algebraic properties associated with variables may also be associated with kernels.</p><h2><a class="nav-anchor" id=".2-The-Expression-Workspace-1" href="#.2-The-Expression-Workspace-1">8.2 The Expression Workspace</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.ws" href="#Reduce.Algebra.ws"><code>Reduce.Algebra.ws</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ws()</code></pre><p>Several mechanisms are available for saving and retrieving previously evaluated expressions. The simplest of these refers to the last algebraic expression simplified. When an assignment of an algebraic expression is made, or an expression is evaluated at the top level, (i.e., not inside a compound statement or procedure) the results of the evaluation are automatically saved in a variable <code>ws</code> that we shall refer to as the workspace. (More precisely, the expression is assigned to the variable <code>ws</code> that is then available for further manipulation.)</p><p><em>Example:</em> If we evaluate the expression <code>(x+y)^2</code> at the top level and next wish to differentiate it with respect to <code>y</code>, we can simply say <span>$julia&gt; Algebra.df(Algebra.ws(),:y)$</span>` to get the desired answer.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/Reduce.jl#L128-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.saveas" href="#Reduce.Algebra.saveas"><code>Reduce.Algebra.saveas</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">saveas(expr)</code></pre><p>If the user wishes to assign the workspace to a variable or expression for later use, the <code>saveas</code> statement can be used. It has the syntax</p><pre><code class="language-Julia">R&quot;saveas ⟨expression⟩&quot;</code></pre><p>For example, after the differentiation in the last example, the workspace holds the expression <code>2*x+2*y</code>. If we wish to assign this to the variable <code>z</code> we can now say</p><pre><code class="language-Julia">julia&gt; Algebra.saveas(:z)</code></pre><p>If the user wishes to save the expression in a form that allows him to use some of its variables as arbitrary parameters, the <code>for all</code> command can be used.</p><p><em>Example:</em></p><pre><code class="language-Julia">R&quot;for all x saveas h(x)&quot;</code></pre><p>with the above expression would mean that <code>h(z)</code> evaluates to <code>2*y+2*z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/unary.jl#L557-L575">source</a></section><p>A further method for referencing more than the last expression is described in chapter 13 on interactive use of REDUCE.</p><h2><a class="nav-anchor" id=".3-Output-of-Expressions-1" href="#.3-Output-of-Expressions-1">8.3 Output of Expressions</a></h2><p>A considerable degree of flexibility is available in REDUCE in the printing of expressions generated during calculations. No explicit format statements are supplied, as these are in most cases of little use in algebraic calculations, where the size of output or its composition is not generally known in advance. Instead, REDUCE provides a series of mode options to the user that should enable him to produce his output in a comprehensible and possibly pleasing form.</p><p>The most extreme option offered is to suppress the output entirely from any top level evaluation. This is accomplished by turning off the switch <code>output</code> which is normally on. It is useful for limiting output when loading large files or producing “clean” output from the prettyprint programs.</p><p>In most circumstances, however, we wish to view the output, so we need to know how to format it appropriately. As we mentioned earlier, an algebraic expression is normally printed in an expanded form, filling the whole output line with terms. Certain output declarations, however, can be used to affect this format. To begin with, we look at an operator for changing the length of the output line.</p><h3><a class="nav-anchor" id=".3.1-LINELENGTH-Operator-1" href="#.3.1-LINELENGTH-Operator-1">8.3.1 LINELENGTH Operator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.linelength" href="#Reduce.linelength"><code>Reduce.linelength</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linelength()</code></pre><p>This operator is used with the syntax</p><pre><code class="language-Julia">Reduce.linelength()::Integer</code></pre><p>and sets the output line length to the integer <code>tput cols</code>. It returns the output line length (so that it can be stored for later resetting of the output line if needed).</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/rexpr.jl#L94-L102">source</a></section><h3><a class="nav-anchor" id=".3.2-Output-Declarations-1" href="#.3.2-Output-Declarations-1">8.3.2 Output Declarations</a></h3><p>We now describe a number of switches and declarations that are available for controlling output formats. It should be noted, however, that the transformation of large expressions to produce these varied output formats can take a lot of computing time and space. If a user wishes to speed up the printing of the output in such cases, he can turn off the switch <code>pri</code>. If this is done, then output is produced in one fixed format, which basically reflects the internal form of the expression, and none of the options below apply. <code>pri</code> is normally on.</p><p>With <code>pri</code> on, the output declarations and switches available are as follows:</p><h4><a class="nav-anchor" id="ORDER-Declaration-1" href="#ORDER-Declaration-1">ORDER Declaration</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.order" href="#Reduce.Algebra.order"><code>Reduce.Algebra.order</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">order(r...)</code></pre><p>The declaration <code>order</code> may be used to order variables on output. The syntax is:</p><pre><code class="language-Julia">julia&gt; Algebra.order(v1,...vn)</code></pre><p>where the <code>vi</code> are kernels. Thus,</p><pre><code class="language-Julia">julia&gt; Algebra.order(:x,:y,:z)</code></pre><p>orders <code>x</code> ahead of <code>y</code>, <code>y</code> ahead of <code>z</code> and all three ahead of other variables not given an order. <code>order(nothing)</code> resets the output order to the system default. The order of variables may be changed by further calls of <code>order</code>, but then the reordered variables would have an order lower than those in earlier <code>order</code> calls. Thus,</p><pre><code class="language-Julia">julia&gt; Algebra.order(:x,:y,:z)  

julia&gt; Algebra.order(:y,:x)</code></pre><p>would order <code>z</code> ahead of <code>y</code> and <code>x</code>. The default ordering is usually alphabetic.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/args.jl#L697-L715">source</a></section><h4><a class="nav-anchor" id="FACTOR-Declaration-1" href="#FACTOR-Declaration-1">FACTOR Declaration</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.factor" href="#Reduce.factor"><code>Reduce.factor</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">factor(r...)</code></pre><p>This declaration takes a list of identifiers or kernels as argument. <code>factor</code> is not a factoring command (use <code>factorize</code> or the <code>factor</code> switch for this purpose); rather it is a separation command. All terms involving fixed powers of the declared expressions are printed as a product of the fixed powers and a sum of the rest of the terms.</p><p>For example, after the declaration</p><pre><code class="language-Julia">julia&gt; Algebra.factor(:x)</code></pre><p>the polynomial <span>$(x + y + 1)^2$</span> will be printed as</p><pre><code class="language-none">         2                  2  
        x  + 2*x*(y + 1) + y  + 2*y + 1</code></pre><p>All expressions involving a given prefix operator may also be factored by putting the operator name in the list of factored identifiers. For example:</p><pre><code class="language-Julia">julia&gt; Algebra.factor(:x,:cos,:(sin(x))</code></pre><p>causes all powers of <code>x</code> and <code>sin(x)</code> and all functions of <code>cos</code> to be factored.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/args.jl#L717-L737">source</a></section><p>Note that <code>factor</code> does not affect the order of its arguments. You should also use <code>order</code> if this is important.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.remfac" href="#Reduce.Algebra.remfac"><code>Reduce.Algebra.remfac</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">remfac(r...)</code></pre><p>The declaration <code>remfac(v1,...,vn)</code> removes the factoring flag from the expressions <code>v1</code> through <code>vn</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/args.jl#L739-L743">source</a></section><h3><a class="nav-anchor" id=".3.3-Output-Control-Switches-1" href="#.3.3-Output-Control-Switches-1">8.3.3 Output Control Switches</a></h3><p>In addition to these declarations, the form of the output can be modified by switching various output control switches using the declarations <code>on</code> and <code>off</code>. We shall illustrate the use of these switches by an example, namely the printing of the expression</p><pre><code class="language-Julia">R&quot;x^2*(y^2+2*y)+x*(y^2+z)/(2*a)&quot;</code></pre><p>The relevant switches are as follows:</p><h4><a class="nav-anchor" id="ALLFAC-Switch-1" href="#ALLFAC-Switch-1">ALLFAC Switch</a></h4><p>This switch will cause the system to search the whole expression, or any sub-expression enclosed in parentheses, for simple multiplicative factors and print them outside the parentheses. Thus our expression with <code>allfac</code> off will print as</p><pre><code class="language-none">    2  2        2          2  
(2*x *y *a + 4*x *y*a + x*y  + x*z)/(2*a)</code></pre><p>and with <code>allfac</code> on as</p><pre><code class="language-none">        2                2  
x*(2*x*y *a + 4*x*y*a + y  + z)/(2*a)</code></pre><p><code>allfac</code> is normally on, and is on in the following examples, except where otherwise stated.</p><h4><a class="nav-anchor" id="DIV-Switch-1" href="#DIV-Switch-1">DIV Switch</a></h4><p>This switch makes the system search the denominator of an expression for simple factors that it divides into the numerator, so that rational fractions and negative powers appear in the output. With <code>div</code> on, our expression would print as</p><pre><code class="language-none">      2                2  (-1)        (-1)  
x*(x*y  + 2*x*y + 1/2*y *a     + 1/2*a    *z)</code></pre><p><code>div</code> is normally off.</p><h4><a class="nav-anchor" id="LIST-Switch-1" href="#LIST-Switch-1">LIST Switch</a></h4><p>This switch causes the system to print each term in any sum on a separate line. With <code>list</code> on, our expression prints as</p><pre><code class="language-none">        2  
x*(2*x*y *a  

    + 4*x*y*a  

       2  
    + y  

    + z)/(2*a)</code></pre><p><code>list</code> is normally off.</p><h4><a class="nav-anchor" id="NOSPLIT-Switch-1" href="#NOSPLIT-Switch-1">NOSPLIT Switch</a></h4><p>Under normal circumstances, the printing routines try to break an expression across lines at a natural point. This is a fairly expensive process. If you are not overly concerned about where the end-of-line breaks come, you can speed up the printing of expressions by turning off the switch <code>nosplit</code>. This switch is normally on.</p><h4><a class="nav-anchor" id="RAT-Switch-1" href="#RAT-Switch-1">RAT Switch</a></h4><p>This switch is only useful with expressions in which variables are factored with <code>factor</code>. With this mode, the overall denominator of the expression is printed with each factored sub-expression. We assume a prior declaration <code>factor(:x)</code> in the following output. We first print the expression with <code>rat</code> set to off:</p><pre><code class="language-none">    2                   2  
(2*x *y*a*(y + 2) + x*(y  + z))/(2*a)</code></pre><p>With <code>rat</code> on the output becomes:</p><pre><code class="language-none"> 2                 2  
x *y*(y + 2) + x*(y  + z)/(2*a)</code></pre><p><code>rat</code> is normally off.</p><p>Next, if we leave <code>x</code> factored, and turn on both <code>div</code> and <code>rat</code>, the result becomes</p><pre><code class="language-none"> 2                    (-1)   2  
x *y*(y + 2) + 1/2*x*a    *(y  + z)</code></pre><p>Finally, with <code>x</code> factored, <code>rat</code> on and <code>allfac</code> off we retrieve the original structure</p><pre><code class="language-none"> 2   2              2  
x *(y  + 2*y) + x*(y  + z)/(2*a)</code></pre><h4><a class="nav-anchor" id="RATPRI-Switch-1" href="#RATPRI-Switch-1">RATPRI Switch</a></h4><p>If the numerator and denominator of an expression can each be printed in one line, the output routines will print them in a two dimensional notation, with numerator and denominator on separate lines and a line of dashes in between. For example, <code>(a+b)/2</code> will print as</p><pre><code class="language-none">A + B  
-----  
  2</code></pre><p>Turning this switch off causes such expressions to be output in a linear form.</p><h4><a class="nav-anchor" id="REVPRI-Switch-1" href="#REVPRI-Switch-1">REVPRI Switch</a></h4><p>The normal ordering of terms in output is from highest to lowest power. In some situations (e.g., when a power series is output), the opposite ordering is more convenient. The switch <code>revpri</code> if on causes such a reverse ordering of terms. For example, the expression <code>y*(x+1)^2+(y+3)^2</code> will normally print as</p><pre><code class="language-none"> 2              2  
X *Y + 2*X*Y + Y  + 7*Y + 9</code></pre><p>whereas with <code>revpri</code> on, it will print as</p><pre><code class="language-none">           2            2  
9 + 7*Y + Y  + 2*X*Y + X *Y</code></pre><h3><a class="nav-anchor" id=".3.4-WRITE-Command-1" href="#.3.4-WRITE-Command-1">8.3.4 WRITE Command</a></h3><p>In simple cases no explicit output command is necessary in REDUCE, since the value of any expression is automatically printed if a semicolon is used as a delimiter. There are, however, several situations in which such a command is useful.</p><p>In a <code>for</code>, <code>while</code>, or <code>repeat</code> statement it may be desired to output something each time the statement within the loop construct is repeated.</p><p>It may be desired for a procedure to output intermediate results or other information while it is running. It may be desired to have results labeled in special ways, especially if the output is directed to a file or device other than the terminal.</p><p>The <code>write</code> command consists of the word <code>write</code> followed by one or more items separated by commas, and followed by a terminator. There are three kinds of items that can be used:</p><ol><li><p>Expressions (including variables and constants). The expression is evaluated, and the result is printed out.</p></li><li><p>Assignments. The expression on the right side of the <code>:=</code> operator is evaluated, and is assigned to the variable on the left; then the symbol on the left is printed, followed by a “<code>:=</code>”, followed by the value of the expression on the right – almost exactly the way an assignment followed by a semicolon prints out normally. (The difference is that if the <code>write</code> is in a <code>for</code> statement and the left-hand side of the assignment is an array position or something similar containing the variable of the <code>for</code> iteration, then the value of that variable is inserted in the printout.)</p></li><li><p>Arbitrary strings of characters, preceded and followed by double-quote marks (e.g., <code>R&quot;~string~&quot;</code>).</p></li></ol><p>The items specified by a single <code>write</code> statement print side by side on one line. (The line is broken automatically if it is too long.) Strings print exactly as quoted. The <code>write</code> command itself however does not return a value.</p><p>The print line is closed at the end of a <code>write</code> command evaluation. Therefore the command <code>R&quot;write ~~&quot;</code> (specifying nothing to be printed except the empty string) causes a line to be skipped.</p><p><em>Examples:</em></p><ol><li><p>If <code>a</code> is <code>x+5</code>, <code>b</code> is itself, <code>c</code> is <code>123</code>, <code>m</code> is an array, and <code>q=3</code>, then</p></li></ol><pre><code class="language-Julia">R&quot;write m(q):=a,~ ~,b/c,~ THANK YOU~&quot;</code></pre><p>will set <code>m(3)</code> to <code>x+5</code> and print</p><pre><code class="language-none">m(q) := x + 5 b/123 THANK YOU</code></pre><p>The blanks between the <code>5</code> and <code>b</code>, and the <code>3</code> and <code>t</code>, come from the blanks in the quoted strings.</p><ol><li><p>To print a table of the squares of the integers from 1 to 20:</p></li></ol><pre><code class="language-Julia">R&quot;for i:=1:20 do write i,~ ~,i^2&quot;</code></pre><ol><li><p>To print a table of the squares of the integers from 1 to 20, and at the same time store them in positions 1 to 20 of an array <code>a</code>:</p></li></ol><pre><code class="language-Julia">R&quot;for i:=1:20 do &lt;&lt;a(i):=i^2; write i,~ ~,a(i)&gt;&gt;&quot;</code></pre><p>This will give us two columns of numbers. If we had used</p><pre><code class="language-Julia">R&quot;for i:=1:20 do write i,~ ~,a(i):=i^2&quot;</code></pre><p>we would also get <code>a(i) :=</code> repeated on each line.</p><ol><li><p>The following more complete example calculates the famous <span>$f$</span> and <span>$g$</span> series, first reported in Sconzo, P., LeSchack, A. R., and Tobey, R., “Symbolic Computation of f and g Series by Computer”, Astronomical Journal 70 (May 1965).</p></li></ol><pre><code class="language-none"> x1:= -sig*(mu+2*eps)$  
 x2:= eps - 2*sig^2$  
 x3:= -3*mu*sig$  
 f:= 1$  
 g:= 0$  
 for i:= 1 step 1 until 10 do begin  
    f1:= -mu*g+x1*df(f,eps)+x2*df(f,sig)+x3*df(f,mu);  
    write ~f(~,i,~) := ~,f1;  
    g1:= f+x1*df(g,eps)+x2*df(g,sig)+x3*df(g,mu);  
    write ~g(~,i,~) := ~,g1;  
    f:=f1$  
    g:=g1$  
   end;</code></pre><p>A portion of the output, to illustrate the printout from the <code>write</code> command, is as follows:</p><pre><code class="language-none">                ... &lt;prior output&gt; ...  
 
                           2  
 F(4) := MU*(3*EPS - 15*SIG  + MU)  
 
 G(4) := 6*SIG*MU  
 
                                    2  
 F(5) := 15*SIG*MU*( - 3*EPS + 7*SIG  - MU)  
 
                           2  
 G(5) := MU*(9*EPS - 45*SIG  + MU)  
 
                ... &lt;more output&gt; ...  </code></pre><h3><a class="nav-anchor" id=".3.5-Suppression-of-Zeros-1" href="#.3.5-Suppression-of-Zeros-1">8.3.5 Suppression of Zeros</a></h3><p>It is sometimes annoying to have zero assignments (i.e. assignments of the form <code>&lt;expression&gt; := 0</code>) printed, especially in printing large arrays with many zero elements. The output from such assignments can be suppressed by turning on the switch <code>nero</code>.</p><h3><a class="nav-anchor" id=".3.6-FORTRAN-Style-Output-Of-Expressions-1" href="#.3.6-FORTRAN-Style-Output-Of-Expressions-1">8.3.6 FORTRAN Style Output Of Expressions</a></h3><p>It is naturally possible to evaluate expressions numerically in REDUCE by giving all variables and sub-expressions numerical values. However, as we pointed out elsewhere the user must declare real arithmetical operation by turning on the switch <code>rounded</code>. However, it should be remembered that arithmetic in REDUCE is not particularly fast, since results are interpreted rather than evaluated in a compiled form. The user with a large amount of numerical computation after all necessary algebraic manipulations have been performed is therefore well advised to perform these calculations in a FORTRAN or similar system. For this purpose, REDUCE offers facilities for users to produce FORTRAN compatible files for numerical processing.</p><p>First, when the switch <code>fort</code> is on, the system will print expressions in a FORTRAN notation. Expressions begin in column seven. If an expression extends over one line, a continuation mark (.) followed by a blank appears on subsequent cards. After a certain number of lines have been produced (according to the value of the variable <code>card_no</code>), a new expression is started. If the expression printed arises from an assignment to a variable, the variable is printed as the name of the expression. Otherwise the expression is given the default name <code>ans</code>. An error occurs if identifiers or numbers are outside the bounds permitted by FORTRAN.</p><p>A second option is to use the <code>write</code> command to produce other programs.</p><p><em>Example:</em> The following REDUCE statements</p><pre><code class="language-none"> on fort;  
 out ~forfil~;  
 write ~C     this is a fortran program~;  
 write ~ 1    format(e13.5)~;  
 write ~      u=1.23~;  
 write ~      v=2.17~;  
 write ~      w=5.2~;  
 x:=(u+v+w)^11;  
 write ~C     it was foolish to expand this expression~;  
 write ~      print 1,x~;  
 write ~      end~;  
 shut ~forfil~;  
 off fort;</code></pre><p>will generate a file <code>forfil</code> that contains:</p><pre><code class="language-none">c this is a fortran program  
 1    format(e13.5)  
      u=1.23  
      v=2.17  
      w=5.2  
      ans1=1320.*u**3*v*w**7+165.*u**3*w**8+55.*u**2*v**9+495.*u  
     . **2*v**8*w+1980.*u**2*v**7*w**2+4620.*u**2*v**6*w**3+  
     . 6930.*u**2*v**5*w**4+6930.*u**2*v**4*w**5+4620.*u**2*v**3*  
     . w**6+1980.*u**2*v**2*w**7+495.*u**2*v*w**8+55.*u**2*w**9+  
     . 11.*u*v**10+110.*u*v**9*w+495.*u*v**8*w**2+1320.*u*v**7*w  
     . **3+2310.*u*v**6*w**4+2772.*u*v**5*w**5+2310.*u*v**4*w**6  
     . +1320.*u*v**3*w**7+495.*u*v**2*w**8+110.*u*v*w**9+11.*u*w  
     . **10+v**11+11.*v**10*w+55.*v**9*w**2+165.*v**8*w**3+330.*  
     . v**7*w**4+462.*v**6*w**5+462.*v**5*w**6+330.*v**4*w**7+  
     . 165.*v**3*w**8+55.*v**2*w**9+11.*v*w**10+w**11  
      x=u**11+11.*u**10*v+11.*u**10*w+55.*u**9*v**2+110.*u**9*v*  
     . w+55.*u**9*w**2+165.*u**8*v**3+495.*u**8*v**2*w+495.*u**8  
     . *v*w**2+165.*u**8*w**3+330.*u**7*v**4+1320.*u**7*v**3*w+  
     . 1980.*u**7*v**2*w**2+1320.*u**7*v*w**3+330.*u**7*w**4+462.  
     . *u**6*v**5+2310.*u**6*v**4*w+4620.*u**6*v**3*w**2+4620.*u  
     . **6*v**2*w**3+2310.*u**6*v*w**4+462.*u**6*w**5+462.*u**5*  
     . v**6+2772.*u**5*v**5*w+6930.*u**5*v**4*w**2+9240.*u**5*v  
     . **3*w**3+6930.*u**5*v**2*w**4+2772.*u**5*v*w**5+462.*u**5  
     . *w**6+330.*u**4*v**7+2310.*u**4*v**6*w+6930.*u**4*v**5*w  
     . **2+11550.*u**4*v**4*w**3+11550.*u**4*v**3*w**4+6930.*u**  
     . 4*v**2*w**5+2310.*u**4*v*w**6+330.*u**4*w**7+165.*u**3*v  
     . **8+1320.*u**3*v**7*w+4620.*u**3*v**6*w**2+9240.*u**3*v**  
     . 5*w**3+11550.*u**3*v**4*w**4+9240.*u**3*v**3*w**5+4620.*u  
     . **3*v**2*w**6+ans1  
c     it was foolish to expand this expression  
      print 1,x  
      end</code></pre><p>If the arguments of a <code>write</code> statement include an expression that requires continuation records, the output will need editing, since the output routine prints the arguments of <code>write</code> sequentially, and the continuation mechanism therefore generates its auxiliary variables after the preceding expression has been printed.</p><p>Finally, since there is no direct analog of <em>list</em> in FORTRAN, a comment line of the form</p><pre><code class="language-none">c ***** invalid fortran construct (list) not printed</code></pre><p>will be printed if you try to print a list with <code>fort</code> on.</p><h4><a class="nav-anchor" id="FORTRAN-Output-Options-1" href="#FORTRAN-Output-Options-1">FORTRAN Output Options</a></h4><p>There are a number of methods available to change the default format of the FORTRAN output.</p><p>The breakup of the expression into subparts is such that the number of continuation lines produced is less than a given number. This number can be modified by the assignment</p><pre><code class="language-Julia">R&quot;card_no := ⟨number⟩&quot;</code></pre><p>where <code>⟨number⟩</code> is the total number of cards allowed in a statement. The default value of <code>card_no</code> is 20.</p><p>The width of the output expression is also adjustable by the assignment</p><pre><code class="language-Julia">R&quot;fort_width := ⟨integer⟩&quot;</code></pre><p><code>fort_width</code> which sets the total width of a given line to <code>⟨integer⟩</code>. The initial FORTRAN output width is 70.</p><p>REDUCE automatically inserts a decimal point after each isolated integer coefficient in a FORTRAN expression (so that, for example, 4 becomes <code>4.</code>). To prevent this, set the <code>period</code> mode switch to <code>off</code>.</p><p>FORTRAN output is normally produced in lower case. If upper case is desired, the switch <code>FORTUPPER</code> should be turned on.</p><p>Finally, the default name <code>ans</code> assigned to an unnamed expression and its subparts can be changed by the operator <code>varname</code>. This takes a single identifier as argument, which then replaces ANS as the expression name. The value of <code>varname</code> is its argument.</p><p>Further facilities for the production of FORTRAN and other language output are provided by the SCOPE and GENTRAN packagesdescribed in chapters 16.26 and 16.60.</p><h3><a class="nav-anchor" id=".3.7-Saving-Expressions-for-Later-Use-as-Input-1" href="#.3.7-Saving-Expressions-for-Later-Use-as-Input-1">8.3.7 Saving Expressions for Later Use as Input</a></h3><p>It is often useful to save an expression on an external file for use later as input in further calculations. The commands for opening and closing output files are explained elsewhere. However, we see in the examples on output of expressions that the standard “natural” method of printing expressions is not compatible with the input syntax. So to print the expression in an input compatible form we must inhibit this natural style by turning off the switch <code>nat</code>. If this is done, a dollar sign will also be printed at the end of the expression.</p><p><em>Example:</em> The following sequence of commands</p><pre><code class="language-none">        off nat; out ~out~; x := (y+z)^2; write ~end~;  
        shut ~out~; on nat;</code></pre><p>will generate a file out that contains</p><pre><code class="language-none">        X := Y**2 + 2*Y*Z + Z**2$  
        END$</code></pre><h3><a class="nav-anchor" id=".3.8-Displaying-Expression-Structure-1" href="#.3.8-Displaying-Expression-Structure-1">8.3.8 Displaying Expression Structure</a></h3><p>In those cases where the final result has a complicated form, it is often convenient to display the skeletal structure of the answer. The operator <code>structr</code>, that takes a single expression as argument, will do this for you. Its syntax is:</p><pre><code class="language-Julia">R&quot;structr(EXPRN:algebraic[,ID1:identifier[,ID2:identifier]])&quot;</code></pre><p>The structure is printed effectively as a tree, in which the subparts are laid out with auxiliary names. If the optional <code>ID1</code> is absent, the auxiliary names are prefixed by the root <code>ans</code>. This root may be changed by the operator <code>varname</code>. If the optional <code>ID1</code> is present, and is an array name, the subparts are named as elements of that array, otherwise <code>ID1</code> is used as the root prefix. (The second optional argument <code>ID2</code> is explained later.)</p><p>The <code>EXPRN</code> can be either a scalar or a matrix expression. Use of any other will result in an error.</p><p><em>Example:</em> Let us suppose that the workspace contains <code>((a+b)^2+c)^3+d</code>. Then the input <code>R&quot;structr ws&quot; will (with</code>exp` off) result in the output:</p><pre><code class="language-none">ans3

   where

                  3
      ans3 := ans2  + d

                  2
      ans2 := ans1  + c

      ans1 := a + b</code></pre><p>The workspace remains unchanged after this operation, since <code>structr</code> in the default situation returns no value (if <code>structr</code> is used as a sub-expression, its value is taken to be 0). In addition, the sub-expressions are normally only displayed and not retained. If you wish to access the sub-expressions with their displayed names, the switch <code>savestructr</code> should be turned on. In this case, <code>structr</code> returns a list whose first element is a representation for the expression, and subsequent elements are the sub-expression relations. Thus, with <code>savestructr</code> on, <code>R&quot;structr ws&quot;</code> in the above example would return</p><pre><code class="language-none">               3              2
{ans3,ans3=ans2  + d,ans2=ans1  + c,ans1=a + b}</code></pre><p>The <code>part</code> operator can be used to retrieve the required parts of the expression. For example, to get the value of <code>ans2</code> in the above, one could say:</p><pre><code class="language-Julia">R&quot;part(ws,3,2)&quot;</code></pre><p>If <code>fort</code> is on, then the results are printed in the reverse order; the algorithm in fact guaranteeing that no sub-expression will be referenced before it is defined. The second optional argument <code>ID2</code> may also be used in this case to name the actual expression (or expressions in the case of a matrix argument).</p><p><em>Example:</em> Let us suppose that <code>m</code>, a 2 by 1 matrix, contains the elements <code>((a+b)^2 + c)^3 + d</code> and <code>(a + b)\*(c + d)</code> respectively, and that V has been declared to be an array. With <code>exp</code> off and <code>fort</code> on, the statement <code>R&quot;structr(2\*m,v,k);&quot;</code> will result in the output</p><pre><code class="language-none">v(1)=a+b  
v(2)=v(1)**2+c  
v(3)=v(2)**3+d  
v(4)=c+d  
k(1,1)=2.*v(3)  
k(2,1)=2.*v(1)*v(4)</code></pre><h2><a class="nav-anchor" id=".4-Changing-the-Internal-Order-of-Variables-1" href="#.4-Changing-the-Internal-Order-of-Variables-1">8.4 Changing the Internal Order of Variables</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reduce.Algebra.korder" href="#Reduce.Algebra.korder"><code>Reduce.Algebra.korder</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">korder(r...)</code></pre><p>The internal ordering of variables (more specifically kernels) can have a significant effect on the space and time associated with a calculation. In its default state, REDUCE uses a specific order for this which may vary between sessions. However, it is possible for the user to change this internal order by means of the declaration <code>korder</code>. The syntax for this is:</p><pre><code class="language-Julia">julia&gt; Algebra.korder(v1,...,vn)</code></pre><p>where the <code>vi</code> are kernels. With this declaration, the <code>vi</code> are ordered internally ahead of any other kernels in the system. <code>v1</code> has the highest order, <code>v2</code> the next highest, and so on. A further call of <code>korder</code> replaces a previous one. <code>korder(nothing)</code> resets the internal order to the system default.</p></div><a class="source-link" target="_blank" href="https://github.com/chakravala/Reduce.jl/blob/337b5eac30168cdceb5e9071da8c3b31c9128f44/src/args.jl#L745-L753">source</a></section><p>Unlike the <code>order</code> declaration, that has a purely cosmetic effect on the way results are printed, the use of <code>korder</code> can have a significant effect on computation time. In critical cases then, the user can experiment with the ordering of the variables used to determine the optimum set for a given problem.</p><h2><a class="nav-anchor" id=".5-Obtaining-Parts-of-Algebraic-Expressions-1" href="#.5-Obtaining-Parts-of-Algebraic-Expressions-1">8.5 Obtaining Parts of Algebraic Expressions</a></h2><p>There are many occasions where it is desirable to obtain a specific part of an expression, or even change such a part to another expression. A number of operators are available in REDUCE for this purpose, and will be described in this section. In addition, operators for obtaining specific parts of polynomials and rational functions (such as a denominator) are described in another section.</p><h3><a class="nav-anchor" id=".5.1-COEFF-Operator-1" href="#.5.1-COEFF-Operator-1">8.5.1 COEFF Operator</a></h3><p>Syntax:</p><pre><code class="language-Julia">R&quot;coeff(EXPRN:polynomial,VAR:kernel)&quot;</code></pre><p><code>coeff</code> is an operator that partitions <code>EXPRN</code> into its various coefficients with respect to <code>VAR</code> and returns them as a list, with the coefficient independent of <code>VAR</code> first.</p><p>Under normal circumstances, an error results if <code>EXPRN</code> is not a polynomial in <code>VAR</code>, although the coefficients themselves can be rational as long as they do not depend on <code>VAR</code>. However, if the switch <code>ratarg</code> is on, denominators are not checked for dependence on <code>VAR</code>, and are taken to be part of the coefficients.</p><p><em>Example:</em></p><pre><code class="language-none">reduce&gt; coeff((y^2+z)^3/z,y);</code></pre><p>returns the result</p><pre><code class="language-none">  2  
{Z ,0,3*Z,0,3,0,1/Z}</code></pre><p>whereas</p><pre><code class="language-none">reduce&gt; coeff((y^2+z)^3/y,y);</code></pre><p>gives an error if <code>ratarg</code> is off, and the result</p><pre><code class="language-none">  3        2  
{Z /Y,0,3*Z /Y,0,3*Z/Y,0,1/Y}</code></pre><p>if <code>ratarg</code> is on.</p><p>The length of the result of <code>coeff</code> is the highest power of <code>VAR</code> encountered plus 1. In the above examples it is 7. In addition, the variable <code>high_pow</code> is set to the highest non-zero power found in <code>EXPRN</code> during the evaluation, and <code>low_pow</code> to the lowest non-zero power, or zero if there is a constant term. If <code>EXPRN</code> is a constant, then <code>high_pow</code> and <code>low_pow</code> are both set to zero.</p><h3><a class="nav-anchor" id=".5.2-COEFFN-Operator-1" href="#.5.2-COEFFN-Operator-1">8.5.2 COEFFN Operator</a></h3><p>The <code>coeffn</code> operator is designed to give the user a particular coefficient of a variable in a polynomial, as opposed to <code>coeff</code> that returns all coefficients. <code>coeffn</code> is used with the syntax</p><pre><code class="language-none">R&quot;coeffn(EXPRN:polynomial,VAR:kernel,N:integer)&quot;</code></pre><p>It returns the <code>n</code>th coefficient of <code>VAR</code> in the polynomial <code>EXPRN</code>.</p><h3><a class="nav-anchor" id=".5.3-PART-Operator-1" href="#.5.3-PART-Operator-1">8.5.3 PART Operator</a></h3><p>Syntax:</p><pre><code class="language-Julia">R&quot;part(EXPRN:algebraic[,INTEXP:integer])&quot;</code></pre><p>This operator works on the form of the expression as printed or as it would have been printed at that point in the calculation bearing in mind all the relevant switch settings at that point. The reader therefore needs some familiarity with the way that expressions are represented in prefix form in REDUCE to use these operators effectively. Furthermore, it is assumed that <code>pri</code> is <code>on</code> at that point in the calculation. The reason for this is that with <code>pri</code> off, an expression is printed by walking the tree representing the expression internally. To save space, it is never actually transformed into the equivalent prefix expression as occurs when <code>pri</code> is on. However, the operations on polynomials described elsewhere can be equally well used in this case to obtain the relevant parts.</p><p>The evaluation proceeds recursively down the integer expression list. In other words,</p><pre><code class="language-Julia">part(⟨expression⟩,⟨integer1⟩,⟨integer2⟩)
→part(part(⟨expression⟩,⟨integer1⟩),⟨integer2⟩)</code></pre><p>and so on, and</p><pre><code class="language-none">PART(⟨expression⟩)→⟨expression⟩</code></pre><p><code>intexp</code> can be any expression that evaluates to an integer. If the integer is positive, then that term of the expression is found. If the integer is 0, the operator is returned. Finally, if the integer is negative, the counting is from the tail of the expression rather than the head.</p><p>For example, if the expression <code>a+b</code> is printed as <code>a+b</code> (i.e., the ordering of the variables is alphabetical), then</p><pre><code class="language-none">        part(a+b,2)  -&gt;   b  
        part(a+b,-1) -&gt;   b  </code></pre><p>and</p><pre><code class="language-none">        part(a+b,0)  -&gt;  plus</code></pre><p>An operator <code>arglength</code> is available to determine the number of arguments of the top level operator in an expression. If the expression does not contain a top level operator, then -1 is returned. For example,</p><pre><code class="language-none">        arglength(a+b+c) -&gt;  3  
        arglength(f())   -&gt;  0  
        arglength(a)     -&gt;  -1</code></pre><h3><a class="nav-anchor" id=".5.4-Substituting-for-Parts-of-Expressions-1" href="#.5.4-Substituting-for-Parts-of-Expressions-1">8.5.4 Substituting for Parts of Expressions</a></h3><p><code>part</code> may also be used to substitute for a given part of an expression. In this case, the <code>part</code> construct appears on the left-hand side of an assignment statement, and the expression to replace the given part on the right-hand side.</p><p>For example, with the normal settings of the REDUCE switches:</p><pre><code class="language-none">        xx := a+b;  
        part(xx,2) := c;   -&gt;  A+C  
        part(c+d,0) := -;   -&gt; C-D</code></pre><p>Note that <code>xx</code> in the above is not changed by this substitution. In addition, unlike expressions such as array and matrix elements that have an instant evaluation property, the values of <code>part(xx,2)</code> and <code>part(c+d,0)</code> are also not changed.</p><footer><hr/><a class="previous" href="07-prefix-ops.html"><span class="direction">Previous</span><span class="title">7 Built-in Prefix Operators</span></a><a class="next" href="09-polynomials.html"><span class="direction">Next</span><span class="title">9 Polynomials and Rationals</span></a></footer></article></body></html>
